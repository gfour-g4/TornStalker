================================================================================
EXPORTED FILES FOR AI CHATBOT
Export Date: 2/23/2026, 7:52:19 PM
Total Files: 22
================================================================================

File: src/config/constants.js
----------------------------------------
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATES & TRACKING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const STATES = ['Traveling', 'Abroad', 'Jail', 'Hospital', 'Okay'];
const BARS = ['energy', 'nerve', 'happy', 'life'];
const COOLDOWNS = ['drug', 'medical', 'booster', 'alcohol'];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EMOJI MAPPINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const EMOJI = {
  // States
  Traveling: 'âœˆï¸',
  Abroad: 'ğŸ—ºï¸',
  Jail: 'ğŸš”',
  Hospital: 'ğŸ¥',
  Okay: 'âœ…',
  Unknown: 'â“',
  
  // Bars
  energy: 'âš¡',
  nerve: 'ğŸ’¢',
  happy: 'ğŸ˜Š',
  life: 'â¤ï¸',
  
  // Cooldowns
  drug: 'ğŸ’Š',
  medical: 'ğŸ©¹',
  booster: 'ğŸ’‰',
  alcohol: 'ğŸº',
  
  // UI
  chain: 'â›“ï¸',
  on: 'ğŸŸ¢',
  off: 'ğŸ”´',
  user: 'ğŸ‘¤',
  faction: 'ğŸ´',
  warning: 'âš ï¸',
  success: 'âœ…',
  error: 'âŒ',
  loading: 'â³',
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLORS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const COLORS = {
  // States
  Traveling: 0x3498db,
  Abroad: 0xf39c12,
  Jail: 0x7f8c8d,
  Hospital: 0xe74c3c,
  Okay: 0x2ecc71,
  
  // UI
  brand: 0x5865f2,
  warn: 0xf39c12,
  good: 0x2ecc71,
  bad: 0xe74c3c,
  info: 0x3498db,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TORN LINKS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const LINKS = {
  // Items
  drugs: 'https://www.torn.com/item.php#drugs-items',
  alcohol: 'https://www.torn.com/item.php#alcohol-items',
  boosters: 'https://www.torn.com/item.php#boosters-items',
  medical: 'https://www.torn.com/factions.php?step=your&type=1#armoury-medical',
  
  // Locations
  hospital: 'https://www.torn.com/hospitalview.php',
  jail: 'https://www.torn.com/jailview.php',
  travel: 'https://www.torn.com/travelagency.php',
  gym: 'https://www.torn.com/gym.php',
  crimes: 'https://www.torn.com/crimes.php',
  home: 'https://www.torn.com/index.php',
  pointsBuilding: 'https://www.torn.com/page.php?sid=points',
  
  // Dynamic
  profile: (id) => `https://www.torn.com/profiles.php?XID=${id}`,
  attack: (id) => `https://www.torn.com/loader.php?sid=attack&user2ID=${id}`,
  faction: (id) => `https://www.torn.com/factions.php?step=profile&ID=${id}`,
  bounty: (id) => `https://www.torn.com/bounties.php?p=add&XID=${id}`,
  trade: (id) => `https://www.torn.com/trade.php#step=start&userID=${id}`,
  mail: (id) => `https://www.torn.com/messages.php#/p=compose&XID=${id}`,
};

// Map cooldowns to their action links
const COOLDOWN_LINKS = {
  drug: LINKS.drugs,
  medical: LINKS.medical,
  booster: LINKS.boosters,
  alcohol: LINKS.alcohol,
};

// Map bars to their action links
const BAR_LINKS = {
  energy: LINKS.gym,
  nerve: LINKS.crimes,
  happy: LINKS.drugs,
  life: LINKS.hospital,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRAVEL DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const DESTINATIONS = [
  'Mexico', 'Cayman Islands', 'Canada', 'Hawaii', 
  'United Kingdom', 'Argentina', 'Switzerland', 
  'Japan', 'China', 'UAE', 'South Africa'
];

const TRAVEL_TIMES = {
  standard_economy: [1560, 2100, 2460, 8040, 9540, 10020, 10500, 13500, 14520, 16260, 17820],
  standard_business: [480, 660, 720, 2400, 2880, 3000, 3180, 4080, 4320, 4860, 5340],
  airstrip: [1080, 1500, 1740, 5640, 6660, 7020, 7380, 9480, 10140, 11400, 12480],
  private: [780, 1080, 1200, 4020, 4800, 4980, 5280, 6780, 7260, 8100, 8940],
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ACTION DESCRIPTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const BAR_ACTIONS = {
  energy: { text: 'Hit the gym!', link: LINKS.gym },
  nerve: { text: 'Commit some crimes!', link: LINKS.crimes },
  happy: { text: 'Time to boost!', link: LINKS.drugs },
  life: { text: 'You\'re at full health!', link: LINKS.home },
};

const COOLDOWN_ACTIONS = {
  drug: { text: 'Take some drugs!', link: LINKS.drugs },
  medical: { text: 'Use faction medical!', link: LINKS.medical },
  booster: { text: 'Use a booster!', link: LINKS.boosters },
  alcohol: { text: 'Have a drink!', link: LINKS.alcohol },
};

module.exports = {
  STATES,
  BARS,
  COOLDOWNS,
  EMOJI,
  COLORS,
  LINKS,
  COOLDOWN_LINKS,
  BAR_LINKS,
  DESTINATIONS,
  TRAVEL_TIMES,
  BAR_ACTIONS,
  COOLDOWN_ACTIONS,
};


================================================================================

File: src/config/index.js
----------------------------------------

require('dotenv').config();

const config = {
  discord: {
    token: process.env.DISCORD_TOKEN,
    ownerId: process.env.OWNER_DISCORD_ID,
    guildId: process.env.GUILD_ID || null,
  },
  
  torn: {
    apiKey: process.env.TORN_API_KEY,
    userIds: process.env.USER_IDS || '',
    factionIds: process.env.FACTION_IDS || '',
  },
  
  timing: {
    requestMs: Number(process.env.REQUEST_INTERVAL_MS) || 5000,
    factionMs: Number(process.env.FACTION_INTERVAL_MS) || 30000,
    barsMs: 60000,
    chainMs: 10000,
  },
  
  persist: process.env.PERSIST_PATH || './data/store.json',
  port: Number(process.env.PORT) || 3000,
  
  defaults: {
    offlineHours: Number(process.env.FACTION_OFFLINE_HOURS) || 24,
  },
};

// Validation
const required = [
  ['discord.token', config.discord.token],
  ['discord.ownerId', config.discord.ownerId],
  ['torn.apiKey', config.torn.apiKey],
];

for (const [name, value] of required) {
  if (!value) {
    throw new Error(`Missing required config: ${name}`);
  }
}

module.exports = config;


================================================================================

File: src/discord/commands.js
----------------------------------------
const { SlashCommandBuilder } = require('discord.js');

const commands = [
  new SlashCommandBuilder()
    .setName('dashboard')
    .setDescription('ğŸ“Š Open the main control panel'),
  
  new SlashCommandBuilder()
    .setName('help')
    .setDescription('ğŸ“– Show help and commands'),
  
  new SlashCommandBuilder()
    .setName('alerts')
    .setDescription('ğŸ”” Configure personal bar/cooldown/chain alerts'),
  
  new SlashCommandBuilder()
    .setName('track')
    .setDescription('ğŸ‘ï¸ Start tracking a user or faction')
    .addSubcommand(sub =>
      sub
        .setName('user')
        .setDescription('Track a Torn user')
        .addIntegerOption(opt =>
          opt
            .setName('id')
            .setDescription('Torn user ID')
            .setRequired(true),
        )
        .addStringOption(opt =>
          opt
            .setName('alerts')
            .setDescription('States to alert on (e.g., "jail, hospital" or "all")'),
        )
        .addStringOption(opt =>
          opt
            .setName('warn')
            .setDescription('Early warnings (e.g., "5m, 2m")'),
        ),
    )
    .addSubcommand(sub =>
      sub
        .setName('faction')
        .setDescription('Track a faction')
        .addIntegerOption(opt =>
          opt
            .setName('id')
            .setDescription('Faction ID')
            .setRequired(true),
        )
        .addStringOption(opt =>
          opt
            .setName('alerts')
            .setDescription('States to alert on'),
        )
        .addStringOption(opt =>
          opt
            .setName('warn')
            .setDescription('Early warnings'),
        )
        .addIntegerOption(opt =>
          opt
            .setName('offline')
            .setDescription('Offline alert hours (default: 24)'),
        ),
    ),
  
  new SlashCommandBuilder()
    .setName('status')
    .setDescription('ğŸ‘ï¸ Check current status of a user or faction')
    .addIntegerOption(opt =>
      opt
        .setName('id')
        .setDescription('User or faction ID')
        .setRequired(true),
    ),
  
  new SlashCommandBuilder()
    .setName('remove')
    .setDescription('ğŸ—‘ï¸ Stop tracking a user or faction')
    .addIntegerOption(opt =>
      opt
        .setName('id')
        .setDescription('User or faction ID')
        .setRequired(true),
    ),
  
  new SlashCommandBuilder()
    .setName('delay')
    .setDescription('â±ï¸ Add delay to travel ETA')
    .addIntegerOption(opt =>
      opt
        .setName('id')
        .setDescription('User ID')
        .setRequired(true),
    )
    .addStringOption(opt =>
      opt
        .setName('time')
        .setDescription('Delay time (e.g., "5m")')
        .setRequired(true),
    ),
];

module.exports = commands.map(c => c.toJSON());


================================================================================

File: src/discord/components.js
----------------------------------------
const {
    ActionRowBuilder,
    StringSelectMenuBuilder,
    ButtonBuilder,
    ButtonStyle,
  } = require('discord.js');
  const store = require('../services/store');
  const { STATES, BARS, COOLDOWNS, EMOJI, LINKS } = require('../config/constants');
  const { capitalize } = require('../utils');
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DASHBOARD
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function dashboardButtons() {
    return [
      new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('dash:users')
          .setLabel('Users')
          .setEmoji('ğŸ‘¤')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('dash:factions')
          .setLabel('Factions')
          .setEmoji('ğŸ´')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('dash:alerts')
          .setLabel('Personal Alerts')
          .setEmoji('ğŸ””')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('dash:refresh')
          .setLabel('Refresh')
          .setEmoji('ğŸ”„')
          .setStyle(ButtonStyle.Secondary),
      ),
    ];
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // USER LIST
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function userListMenu() {
    const entries = Object.entries(store.watchers).slice(0, 25);
    
    const rows = [];
    
    if (entries.length) {
      rows.push(
        new ActionRowBuilder().addComponents(
          new StringSelectMenuBuilder()
            .setCustomId('select:user')
            .setPlaceholder('Select a user to configure...')
            .addOptions(entries.map(([id, cfg]) => ({
              label: cfg.name || `User ${id}`,
              description: `${cfg.enabled === false ? 'Paused' : 'Active'} â€¢ ${cfg.lastState || 'Unknown'}`,
              value: id,
              emoji: cfg.enabled === false ? EMOJI.off : EMOJI.on,
            }))),
        ),
      );
    }
    
    rows.push(
      new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('dash:main')
          .setLabel('Back')
          .setEmoji('â—€ï¸')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('modal:adduser')
          .setLabel('Add User')
          .setEmoji('â•')
          .setStyle(ButtonStyle.Success),
      ),
    );
    
    return rows;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FACTION LIST
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function factionListMenu() {
    const entries = Object.entries(store.factions.items).slice(0, 25);
    
    const rows = [];
    
    if (entries.length) {
      rows.push(
        new ActionRowBuilder().addComponents(
          new StringSelectMenuBuilder()
            .setCustomId('select:faction')
            .setPlaceholder('Select a faction to configure...')
            .addOptions(entries.map(([id, f]) => ({
              label: f.name || `Faction ${id}`,
              description: `${Object.keys(f.members || {}).length} members`,
              value: id,
              emoji: f.enabled === false ? EMOJI.off : EMOJI.on,
            }))),
        ),
      );
    }
    
    rows.push(
      new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('dash:main')
          .setLabel('Back')
          .setEmoji('â—€ï¸')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('modal:addfaction')
          .setLabel('Add Faction')
          .setEmoji('â•')
          .setStyle(ButtonStyle.Success),
      ),
    );
    
    return rows;
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ALERTS CONFIG
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function alertsButtons() {
    const { self } = store.data;
    
    const barRow = new ActionRowBuilder().addComponents(
      ...BARS.map(b =>
        new ButtonBuilder()
          .setCustomId(`toggle:bar:${b}`)
          .setLabel(capitalize(b))
          .setEmoji(EMOJI[b])
          .setStyle(self.bars[b] ? ButtonStyle.Success : ButtonStyle.Secondary),
      ),
    );
    
    const cdRow = new ActionRowBuilder().addComponents(
      ...COOLDOWNS.map(c =>
        new ButtonBuilder()
          .setCustomId(`toggle:cd:${c}`)
          .setLabel(capitalize(c))
          .setEmoji(EMOJI[c])
          .setStyle(self.cooldowns[c] ? ButtonStyle.Success : ButtonStyle.Secondary),
      ),
    );
    
    const chainRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('toggle:chain')
        .setLabel('Chain Alerts')
        .setEmoji(EMOJI.chain)
        .setStyle(self.chain.enabled ? ButtonStyle.Success : ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('modal:chain')
        .setLabel('Configure')
        .setEmoji('âš™ï¸')
        .setStyle(ButtonStyle.Primary),
    );
    
    // Combine addiction and racing into one row to stay within Discord's 5-row limit
    const addictionRacingRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('toggle:addiction')
        .setLabel('Addiction Check')
        .setEmoji('âš ï¸')
        .setStyle((self.addiction.dailyCheck?.enabled) ? ButtonStyle.Success : ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('modal:addiction')
        .setLabel('Configure')
        .setEmoji('âš™ï¸')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('toggle:racing')
        .setLabel('Racing Reminders')
        .setEmoji('ğŸï¸')
        .setStyle(self.racing.enabled ? ButtonStyle.Success : ButtonStyle.Secondary),
    );
    
    const navRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('dash:main')
        .setLabel('Back')
        .setEmoji('â—€ï¸')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('alerts:refresh')
        .setLabel('Refresh Data')
        .setEmoji('ğŸ”„')
        .setStyle(ButtonStyle.Primary),
    );
    
    return [barRow, cdRow, chainRow, addictionRacingRow, navRow];
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // USER CONFIG
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function userConfig(userId) {
    const cfg = store.watchers[userId];
    if (!cfg) return [];
    
    const stateRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId(`states:${userId}`)
        .setPlaceholder('Select alert states...')
        .setMinValues(0)
        .setMaxValues(STATES.length)
        .addOptions(STATES.map(s => ({
          label: s,
          value: s,
          emoji: EMOJI[s],
          default: cfg.states?.includes(s),
        }))),
    );
    
    const actionRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`toggle:user:${userId}`)
        .setLabel(cfg.enabled === false ? 'Enable' : 'Pause')
        .setStyle(cfg.enabled === false ? ButtonStyle.Success : ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId(`modal:userwarn:${userId}`)
        .setLabel('Warnings')
        .setEmoji('â°')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId(`refresh:user:${userId}`)
        .setLabel('Refresh')
        .setEmoji('ğŸ”„')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId(`remove:user:${userId}`)
        .setLabel('Remove')
        .setStyle(ButtonStyle.Danger),
    );
    
    const navRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('dash:users')
        .setLabel('Back')
        .setEmoji('â—€ï¸')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setURL(LINKS.profile(userId))
        .setLabel('Torn Profile')
        .setStyle(ButtonStyle.Link),
      new ButtonBuilder()
        .setURL(LINKS.attack(userId))
        .setLabel('Attack')
        .setStyle(ButtonStyle.Link),
    );
    
    return [stateRow, actionRow, navRow];
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FACTION CONFIG
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function factionConfig(factionId) {
    const f = store.factions.items[factionId];
    if (!f) return [];
    
    const stateRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId(`fstates:${factionId}`)
        .setPlaceholder('Select alert states...')
        .setMinValues(0)
        .setMaxValues(STATES.length)
        .addOptions(STATES.map(s => ({
          label: s,
          value: s,
          emoji: EMOJI[s],
          default: f.states?.includes(s),
        }))),
    );
    
    const featureRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`toggle:faction:${factionId}`)
        .setLabel(f.enabled === false ? 'Enable' : 'Pause')
        .setStyle(f.enabled === false ? ButtonStyle.Success : ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId(`toggle:foffline:${factionId}`)
        .setLabel(`Offline (${f.offline?.hours || 24}h)`)
        .setEmoji('ğŸ˜´')
        .setStyle(f.offline?.enabled !== false ? ButtonStyle.Success : ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId(`toggle:fdaily:${factionId}`)
        .setLabel('Daily')
        .setEmoji('ğŸ“ˆ')
        .setStyle(f.daily?.enabled !== false ? ButtonStyle.Success : ButtonStyle.Secondary),
    );
    
    const actionRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`modal:factionwarn:${factionId}`)
        .setLabel('Warnings')
        .setEmoji('â°')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId(`modal:factionoffline:${factionId}`)
        .setLabel('Offline Hours')
        .setEmoji('âš™ï¸')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId(`remove:faction:${factionId}`)
        .setLabel('Remove')
        .setStyle(ButtonStyle.Danger),
    );
    
    const navRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('dash:factions')
        .setLabel('Back')
        .setEmoji('â—€ï¸')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setURL(LINKS.faction(factionId))
        .setLabel('View Faction')
        .setStyle(ButtonStyle.Link),
    );
    
    return [stateRow, featureRow, actionRow, navRow];
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // QUICK ACTIONS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  function quickActions(userId, state) {
    const buttons = [
      new ButtonBuilder()
        .setCustomId(`refresh:user:${userId}`)
        .setLabel('Refresh')
        .setEmoji('ğŸ”„')
        .setStyle(ButtonStyle.Secondary),
    ];
    
    if (state === 'Traveling') {
      buttons.push(
        new ButtonBuilder()
          .setCustomId(`modal:delay:${userId}`)
          .setLabel('Add Delay')
          .setEmoji('â±ï¸')
          .setStyle(ButtonStyle.Primary),
      );
    }
    
    buttons.push(
      new ButtonBuilder()
        .setURL(LINKS.profile(userId))
        .setLabel('Profile')
        .setStyle(ButtonStyle.Link),
      new ButtonBuilder()
        .setURL(LINKS.attack(userId))
        .setLabel('Attack')
        .setStyle(ButtonStyle.Link),
    );
    
    return [new ActionRowBuilder().addComponents(buttons)];
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EXPORTS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  module.exports = {
    dashboardButtons,
    userListMenu,
    factionListMenu,
    alertsButtons,
    userConfig,
    factionConfig,
    quickActions,
  };

================================================================================

File: src/discord/embeds.js
----------------------------------------
const { EmbedBuilder } = require('discord.js');
const store = require('../services/store');
const { 
  STATES, BARS, COOLDOWNS, 
  EMOJI, COLORS, LINKS, 
  BAR_LINKS, COOLDOWN_LINKS,
  BAR_ACTIONS, COOLDOWN_ACTIONS,
} = require('../config/constants');
const { 
  formatTime, discordTimestamp, 
  progressBar, capitalize, formatNumber,
  formatDestination, getETA,
} = require('../utils');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DASHBOARD & OVERVIEW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function dashboard() {
  const stats = store.getStats();
  const { self } = store.data;
  
  // Bar status with values
  const barLines = BARS.map(b => {
    const on = self.bars[b];
    const last = self.bars.last[b];
    const val = last ? `\`${last.current}/${last.maximum}\`` : '`â€”`';
    return `${EMOJI[b]} ${capitalize(b)}: ${on ? EMOJI.on : EMOJI.off} ${val}`;
  }).join('\n');
  
  // Cooldown status
  const cdLines = COOLDOWNS.map(c => {
    const on = self.cooldowns[c];
    const remaining = self.cooldowns.last[c] || 0;
    const status = remaining > 0 ? `â± ${formatTime(remaining)}` : 'âœ“ Ready';
    return `${EMOJI[c]} ${capitalize(c)}: ${on ? EMOJI.on : EMOJI.off} ${status}`;
  }).join('\n');
  
  // Chain config
  const chain = self.chain;
  const chainInfo = chain.enabled
    ? `${EMOJI.on} Min: **${chain.min}** â€¢ Alerts: ${chain.thresholds.map(formatTime).join(', ')}`
    : EMOJI.off;
  
  return new EmbedBuilder()
    .setColor(COLORS.brand)
    .setTitle('ğŸ“Š Torn Tracker Dashboard')
    .setDescription([
      `Monitoring **${stats.users.active}** users, **${stats.factions.active}** factions`,
      `(${stats.factions.members} total members)`,
    ].join('\n'))
    .addFields(
      {
        name: `${EMOJI.user} Users`,
        value: stats.users.total 
          ? `**${stats.users.active}**/${stats.users.total} active` 
          : '*None*',
        inline: true,
      },
      {
        name: `${EMOJI.faction} Factions`,
        value: stats.factions.total 
          ? `**${stats.factions.active}**/${stats.factions.total} active` 
          : '*None*',
        inline: true,
      },
      {
        name: 'ğŸ“¡ Status',
        value: `${EMOJI.on} Online`,
        inline: true,
      },
      { name: 'âš¡ Bars', value: barLines, inline: true },
      { name: 'ğŸ’Š Cooldowns', value: cdLines, inline: true },
      { name: '\u200b', value: '\u200b', inline: true },
      { name: `${EMOJI.chain} Chain`, value: chainInfo, inline: false },
    )
    .setFooter({ text: 'Use buttons to configure â€¢ /help for commands' })
    .setTimestamp();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USER VIEWS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function userList(page = 0, perPage = 10) {
  const entries = Object.entries(store.watchers);
  
  if (!entries.length) {
    return new EmbedBuilder()
      .setColor(COLORS.brand)
      .setTitle(`${EMOJI.user} Tracked Users`)
      .setDescription([
        'No users tracked yet.',
        '',
        '**Quick Start:**',
        'â€¢ Use `/track user <id>` to add someone',
        'â€¢ Get user IDs from their Torn profile URL',
      ].join('\n'))
      .setFooter({ text: 'Track targets to get notified when they leave hospital/jail!' });
  }
  
  const totalPages = Math.ceil(entries.length / perPage);
  const pageEntries = entries.slice(page * perPage, (page + 1) * perPage);
  
  const lines = pageEntries.map(([id, cfg]) => {
    const status = cfg.enabled === false ? EMOJI.off : EMOJI.on;
    const stateEmoji = EMOJI[cfg.lastState] || EMOJI.Unknown;
    const states = cfg.states?.length
      ? cfg.states.map(s => EMOJI[s]).join('')
      : '`none`';
    const pre = cfg.preTimesSec?.length
      ? `\nâ”ƒ â° ${cfg.preTimesSec.map(formatTime).join(', ')}`
      : '';
    
    return [
      `${status} **[${cfg.name || 'Unknown'}](${LINKS.profile(id)})** \`[${id}]\``,
      `â”ƒ ${stateEmoji} ${cfg.lastState || 'Unknown'}`,
      `â”ƒ ğŸ”” ${states}${pre}`,
    ].join('\n');
  });
  
  return new EmbedBuilder()
    .setColor(COLORS.brand)
    .setTitle(`${EMOJI.user} Tracked Users (${entries.length})`)
    .setDescription(lines.join('\n\n'))
    .setFooter({ 
      text: totalPages > 1 
        ? `Page ${page + 1}/${totalPages} â€¢ Select user to configure`
        : 'Select a user to configure',
    });
}

function userStatus(userId, profile, cfg) {
  const status = profile?.status || {};
  const state = status.state || 'Unknown';
  const travel = cfg?.travel;
  
  const embed = new EmbedBuilder()
    .setColor(COLORS[state] || COLORS.brand)
    .setAuthor({
      name: `${profile?.name || cfg?.name || 'User'} [${userId}]`,
      url: LINKS.profile(userId),
    })
    .setTitle(`${EMOJI[state] || EMOJI.Unknown} ${state}`)
    .setURL(LINKS.profile(userId))
    .setTimestamp();
  
  const lines = [];
  if (status.description) {
    lines.push(`> ${status.description}`);
  }
  
  // State-specific info with action links
  if (state === 'Traveling' && travel?.earliest) {
    const eta = getETA(travel);
    lines.push(
      '',
      `âœˆï¸ ${formatDestination(travel)}`,
      `**ETA:** ${discordTimestamp(eta, 'R')} (${discordTimestamp(eta, 't')})`,
    );
  } else if (state === 'Jail' && status.until) {
    const until = Number(status.until);
    lines.push(
      '',
      `**Released:** ${discordTimestamp(until, 'R')} (${discordTimestamp(until, 't')})`,
      `ğŸ”— [View in Jail](${LINKS.jail})`,
    );
  } else if (state === 'Hospital' && status.until) {
    const until = Number(status.until);
    lines.push(
      '',
      `**Discharged:** ${discordTimestamp(until, 'R')} (${discordTimestamp(until, 't')})`,
      `ğŸ”— [View in Hospital](${LINKS.hospital})`,
    );
  } else if (state === 'Okay') {
    lines.push('', `ğŸ¯ [Attack](${LINKS.attack(userId)}) â€¢ [Profile](${LINKS.profile(userId)})`);
  } else if (state === 'Abroad') {
    lines.push('', `ğŸ”— [Travel Agency](${LINKS.travel})`);
  }
  
  // Last action
  const lastAction = profile?.last_action?.timestamp;
  if (lastAction) {
    lines.push('', `**Last Active:** ${discordTimestamp(lastAction, 'R')}`);
  }
  
  embed.setDescription(lines.join('\n') || '*No additional info*');
  
  // Tracking configuration
  if (cfg) {
    const alerts = cfg.states?.length
      ? cfg.states.map(s => `${EMOJI[s]} ${s}`).join('\n')
      : '*None*';
    
    const warnings = cfg.preTimesSec?.length
      ? cfg.preTimesSec.map(formatTime).join(', ')
      : '*None*';
    
    const statusText = cfg.enabled === false
      ? `${EMOJI.off} Paused`
      : `${EMOJI.on} Active`;
    
    embed.addFields(
      { name: 'ğŸ”” Alerts', value: alerts, inline: true },
      { name: 'â° Warnings', value: warnings, inline: true },
      { name: 'ğŸ“¡ Status', value: statusText, inline: true },
    );
  }
  
  return embed;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FACTION VIEWS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function factionList(page = 0, perPage = 5) {
  const entries = Object.entries(store.factions.items);
  
  if (!entries.length) {
    return new EmbedBuilder()
      .setColor(COLORS.brand)
      .setTitle(`${EMOJI.faction} Tracked Factions`)
      .setDescription([
        'No factions tracked yet.',
        '',
        '**Quick Start:**',
        'â€¢ Use `/track faction <id>` to add one',
        'â€¢ Get faction IDs from the faction page URL',
      ].join('\n'))
      .setFooter({ text: 'Track your faction to monitor member activity!' });
  }
  
  const totalPages = Math.ceil(entries.length / perPage);
  const pageEntries = entries.slice(page * perPage, (page + 1) * perPage);
  
  const lines = pageEntries.map(([id, f]) => {
    const status = f.enabled === false ? EMOJI.off : EMOJI.on;
    const memberCount = Object.keys(f.members || {}).length;
    const states = f.states?.length
      ? f.states.map(s => EMOJI[s]).join('')
      : '`none`';
    
    const features = [
      f.offline?.enabled !== false ? `ğŸ˜´ >${f.offline?.hours || 24}h` : null,
      f.daily?.enabled !== false ? 'ğŸ“ˆ Daily' : null,
    ].filter(Boolean).join(' â€¢ ');
    
    return [
      `${status} **[${f.name || `Faction ${id}`}](${LINKS.faction(id)})** \`[${id}]\``,
      `â”ƒ ğŸ‘¥ ${memberCount} members`,
      `â”ƒ ğŸ”” ${states}`,
      features ? `â”ƒ ${features}` : null,
    ].filter(Boolean).join('\n');
  });
  
  return new EmbedBuilder()
    .setColor(COLORS.brand)
    .setTitle(`${EMOJI.faction} Tracked Factions (${entries.length})`)
    .setDescription(lines.join('\n\n'))
    .setFooter({
      text: totalPages > 1
        ? `Page ${page + 1}/${totalPages} â€¢ Select faction to configure`
        : 'Select a faction to configure',
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERSONAL ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function alertsConfig() {
  const { self } = store.data;
  
  const barLines = BARS.map(b => {
    const on = self.bars[b];
    const last = self.bars.last[b];
    const bar = last 
      ? progressBar(last.current || 0, last.maximum || 100, 10)
      : '`No data`';
    const link = BAR_LINKS[b] ? `[Use â†’](${BAR_LINKS[b]})` : '';
    
    return `${EMOJI[b]} **${capitalize(b)}** ${on ? EMOJI.on : EMOJI.off}\nâ”— ${bar} ${link}`;
  });
  
  const cdLines = COOLDOWNS.map(c => {
    const on = self.cooldowns[c];
    const remaining = self.cooldowns.last[c] || 0;
    const status = remaining > 0 ? `â± ${formatTime(remaining)}` : 'âœ… Ready';
    const link = COOLDOWN_LINKS[c] ? `[Use â†’](${COOLDOWN_LINKS[c]})` : '';
    
    return `${EMOJI[c]} **${capitalize(c)}** ${on ? EMOJI.on : EMOJI.off}\nâ”— ${status} ${link}`;
  });
  
  const chain = self.chain;
  const chainLine = chain.enabled
    ? `${EMOJI.on} **Enabled**\nâ”— Min: **${chain.min}** â€¢ Alerts: ${chain.thresholds.map(formatTime).join(', ')}`
    : `${EMOJI.off} **Disabled**`;
  
  // Addiction config
  const addiction = self.addiction;
  const addictionDailyCheck = addiction.dailyCheck || {};
  const addictionLine = addiction.dailyCheck?.enabled
    ? `${EMOJI.on} **Enabled**\nâ”— Threshold: **${addiction.threshold ?? -5}** â€¢ Check: **${String(addictionDailyCheck.hour ?? 18).padStart(2, '0')}:${String(addictionDailyCheck.minute ?? 10).padStart(2, '0')}** Torn time`
    : `${EMOJI.off} **Disabled**`;
  
  // Racing config
  const racing = self.racing;
  const racingLine = racing.enabled
    ? `${EMOJI.on} **Enabled**\nâ”— Reminds you to join a race when not in one`
    : `${EMOJI.off} **Disabled**`;
  
  return new EmbedBuilder()
    .setColor(COLORS.brand)
    .setTitle('ğŸ”” Personal Alerts')
    .setDescription('Get notified when your bars fill, cooldowns expire, or other events occur.')
    .addFields(
      { name: 'âš¡ Bar Alerts (full)', value: barLines.join('\n\n'), inline: false },
      { name: 'ğŸ’Š Cooldown Alerts (ready)', value: cdLines.join('\n\n'), inline: false },
      { name: 'â›“ï¸ Chain Alerts', value: chainLine, inline: false },
      { name: 'âš ï¸ Addiction Daily Check', value: addictionLine, inline: false },
      { name: 'ğŸï¸ Racing Reminders', value: racingLine, inline: false },
    )
    .setFooter({ text: 'Toggle with buttons below' })
    .setTimestamp();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOTIFICATIONS - State Changes
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function stateChange(userId, name, oldState, newState, status, travel) {
  const lines = [];
  
  if (status?.description) {
    lines.push(`> ${status.description}`);
  }
  
  if (newState === 'Traveling' && travel?.earliest) {
    const eta = getETA(travel);
    lines.push(
      '',
      `âœˆï¸ ${formatDestination(travel)}`,
      `**ETA:** ${discordTimestamp(eta, 'R')}`,
    );
  } else if (newState === 'Jail' && status?.until) {
    const until = Number(status.until);
    lines.push(
      '',
      `**Released:** ${discordTimestamp(until, 'R')}`,
      `ğŸ”— [View in Jail](${LINKS.jail})`,
    );
  } else if (newState === 'Hospital' && status?.until) {
    const until = Number(status.until);
    lines.push(
      '',
      `**Discharged:** ${discordTimestamp(until, 'R')}`,
      `ğŸ”— [View in Hospital](${LINKS.hospital})`,
    );
  } else if (newState === 'Okay' && oldState !== 'Okay') {
    lines.push('', `ğŸ¯ **[Attack Now!](${LINKS.attack(userId)})**`);
  }
  
  return new EmbedBuilder()
    .setColor(COLORS[newState] || COLORS.brand)
    .setTitle(`${EMOJI[newState] || EMOJI.Unknown} ${name} â†’ ${newState}`)
    .setURL(LINKS.profile(userId))
    .setDescription(lines.join('\n') || null)
    .addFields({
      name: 'Previous',
      value: `${EMOJI[oldState] || EMOJI.Unknown} ${oldState || 'Unknown'}`,
      inline: true,
    })
    .setFooter({ text: `ID: ${userId}` })
    .setTimestamp();
}

function preAlert(name, userId, state, endAt, left) {
  const stateLinks = {
    Jail: `[View in Jail](${LINKS.jail})`,
    Hospital: `[View in Hospital](${LINKS.hospital})`,
    Traveling: `[Travel Agency](${LINKS.travel})`,
  };
  
  return new EmbedBuilder()
    .setColor(COLORS.warn)
    .setTitle(`â° ${name} - ${state} ending soon!`)
    .setURL(LINKS.profile(userId))
    .setDescription([
      `**Ends:** ${discordTimestamp(endAt, 'R')} (${discordTimestamp(endAt, 't')})`,
      `**Time left:** ~${formatTime(left)}`,
      '',
      `ğŸ¯ [Attack](${LINKS.attack(userId)})`,
      stateLinks[state] || '',
    ].filter(Boolean).join('\n'))
    .setFooter({ text: `ID: ${userId} â€¢ Get ready!` })
    .setTimestamp();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOTIFICATIONS - Personal Alerts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function barFull(kind, bar) {
  const action = BAR_ACTIONS[kind] || { text: '', link: '' };
  
  return new EmbedBuilder()
    .setColor(COLORS.good)
    .setTitle(`${EMOJI[kind]} ${capitalize(kind)} is FULL!`)
    .setDescription([
      progressBar(bar.current, bar.maximum, 20),
      `**${formatNumber(bar.current)}** / **${formatNumber(bar.maximum)}**`,
      '',
      action.text,
      action.link ? `ğŸ”— [Go Now â†’](${action.link})` : '',
    ].filter(Boolean).join('\n'))
    .setTimestamp();
}

function cooldownReady(kind) {
  const action = COOLDOWN_ACTIONS[kind] || { text: 'Cooldown ready!', link: '' };
  
  return new EmbedBuilder()
    .setColor(COLORS.good)
    .setTitle(`${EMOJI[kind]} ${capitalize(kind)} Cooldown Ready!`)
    .setDescription([
      action.text,
      action.link ? `ğŸ”— [Use Now â†’](${action.link})` : '',
    ].filter(Boolean).join('\n'))
    .setTimestamp();
}

function chainAlert(chain, threshold) {
  const urgent = chain.timeout <= 30;
  const bar = progressBar(chain.timeout, 300, 20, { showValues: false });
  const pct = Math.round((chain.timeout / 300) * 100);
  
  return new EmbedBuilder()
    .setColor(urgent ? COLORS.bad : COLORS.warn)
    .setTitle(`${urgent ? 'ğŸš¨' : EMOJI.chain} Chain Alert! ${urgent ? 'ğŸš¨' : ''}`)
    .setDescription([
      `**Chain:** ${formatNumber(chain.current)} / ${formatNumber(chain.maximum)}`,
      `**Time Left:** ${formatTime(chain.timeout)} (${pct}%)`,
      '',
      bar,
      '',
      urgent ? 'âš ï¸ **CHAIN ABOUT TO DROP!**' : `Alert at: ${formatTime(threshold)}`,
    ].join('\n'))
    .setTimestamp();
}

function addictionRehabAlert(addiction, threshold) {
  // Calculate tomorrow 4pm Torn time (UTC)
  const now = new Date();
  const tomorrow = new Date(Date.UTC(
    now.getUTCFullYear(),
    now.getUTCMonth(),
    now.getUTCDate() + 1,
    16, 0, 0 // 4:00pm UTC
  ));
  const tomorrowTimestamp = Math.floor(tomorrow.getTime() / 1000);
  
  return new EmbedBuilder()
    .setColor(COLORS.warn)
    .setTitle('âš ï¸ Company Addiction Alert')
    .setDescription([
      `**Current Addiction:** ${addiction}`,
      `**Threshold:** ${threshold}`,
      '',
      'âš ï¸ **Go to rehab before tomorrow 4pm!**',
      `**Deadline:** ${discordTimestamp(tomorrowTimestamp, 'R')} (${discordTimestamp(tomorrowTimestamp, 't')})`,
      '',
      'ğŸ”— [Rehab](https://www.torn.com/city.php#rehab)',
    ].join('\n'))
    .setTimestamp();
}

function racingJoinReminder() {
  return new EmbedBuilder()
    .setColor(COLORS.info)
    .setTitle('ğŸï¸ Racing Reminder')
    .setDescription([
      'You are not currently in a race.',
      '',
      'ğŸ”— [Join a Race](https://www.torn.com/loader.php?sid=racing)',
    ].join('\n'))
    .setTimestamp();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOTIFICATIONS - Faction Alerts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function factionMemberChange(fName, fid, uid, member, oldState, newState, travel) {
  const lines = [`**Faction:** [${fName}](${LINKS.faction(fid)})`];
  
  if (newState === 'Traveling' && travel?.earliest) {
    const eta = getETA(travel);
    lines.push('', `âœˆï¸ ${formatDestination(travel)}`, `**ETA:** ${discordTimestamp(eta, 'R')}`);
  } else if (newState === 'Jail' && member?.status?.until) {
    lines.push('', `**Released:** ${discordTimestamp(Number(member.status.until), 'R')}`);
  } else if (newState === 'Hospital' && member?.status?.until) {
    lines.push('', `**Discharged:** ${discordTimestamp(Number(member.status.until), 'R')}`);
  } else if (newState === 'Okay' && ['Jail', 'Hospital'].includes(oldState)) {
    lines.push('', `ğŸ¯ [Attack](${LINKS.attack(uid)})`);
  }
  
  return new EmbedBuilder()
    .setColor(COLORS[newState] || COLORS.brand)
    .setTitle(`${EMOJI[newState] || EMOJI.Unknown} ${member.name} â†’ ${newState}`)
    .setURL(LINKS.profile(uid))
    .setDescription(lines.join('\n'))
    .addFields({
      name: 'Previous',
      value: `${EMOJI[oldState] || EMOJI.Unknown} ${oldState || 'Unknown'}`,
      inline: true,
    })
    .setFooter({ text: `Member ID: ${uid}` })
    .setTimestamp();
}

function factionJoinLeave(type, fName, fid, uid, name) {
  const isJoin = type === 'join';
  
  return new EmbedBuilder()
    .setColor(isJoin ? COLORS.good : COLORS.bad)
    .setTitle(`${isJoin ? 'ğŸŸ¢ Member Joined' : 'ğŸ”´ Member Left'}`)
    .setURL(LINKS.profile(uid))
    .setDescription([
      `**${name}** has ${isJoin ? 'joined' : 'left'} **${fName}**`,
      '',
      `ğŸ‘¤ [Profile](${LINKS.profile(uid)})`,
      `ğŸ´ [Faction](${LINKS.faction(fid)})`,
    ].join('\n'))
    .setFooter({ text: `ID: ${uid}` })
    .setTimestamp();
}

function factionOffline(fName, fid, uid, name, lastTs, hours) {
  const lastSeen = Number(lastTs);
  const offlineHours = Math.floor((Date.now() / 1000 - lastSeen) / 3600);
  
  return new EmbedBuilder()
    .setColor(COLORS.warn)
    .setTitle(`ğŸ˜´ ${name} - Inactive`)
    .setURL(LINKS.profile(uid))
    .setDescription([
      `**Faction:** [${fName}](${LINKS.faction(fid)})`,
      '',
      `**Last seen:** ${discordTimestamp(lastSeen, 'R')}`,
      `**Offline:** ~${offlineHours} hours`,
      '',
      `âš ï¸ Exceeds ${hours}h threshold`,
    ].join('\n'))
    .setFooter({ text: `ID: ${uid}` })
    .setTimestamp();
}

function factionDaily(fName, fid, delta, total) {
  const up = delta >= 0;
  
  return new EmbedBuilder()
    .setColor(up ? COLORS.good : COLORS.warn)
    .setTitle(`ğŸ“Š ${fName} - Daily Report`)
    .setURL(LINKS.faction(fid))
    .setDescription([
      `${up ? 'ğŸ“ˆ' : 'ğŸ“‰'} **${up ? '+' : ''}${formatNumber(delta)}** respect today`,
      `**Total:** ${formatNumber(total)} respect`,
    ].join('\n'))
    .setTimestamp();
}

function factionMilestone(fName, fid, respect) {
  const milestone = Math.floor(respect / 100000) * 100000;
  
  return new EmbedBuilder()
    .setColor(COLORS.good)
    .setTitle('ğŸ‰ Milestone Reached!')
    .setURL(LINKS.faction(fid))
    .setDescription([
      `**${fName}** hit **${formatNumber(milestone)}** respect!`,
      '',
      'ğŸŠ Congratulations!',
    ].join('\n'))
    .setTimestamp();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELP & UTILITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function help() {
  return new EmbedBuilder()
    .setColor(COLORS.brand)
    .setTitle('ğŸ“– Torn Tracker Help')
    .setDescription('Track players, factions, and get personal alerts.')
    .addFields(
      {
        name: 'ğŸ“Š Overview',
        value: [
          '`/dashboard` - Main control panel',
          '`/status <id>` - Quick status check',
        ].join('\n'),
        inline: false,
      },
      {
        name: 'ğŸ‘¤ User Tracking',
        value: [
          '`/track user <id>` - Add user',
          '  `alerts`: States (jail, hospital, okay, traveling)',
          '  `warn`: Early warnings (5m, 2m)',
          '`/remove <id>` - Stop tracking',
          '`/delay <id> <time>` - Add travel delay',
        ].join('\n'),
        inline: false,
      },
      {
        name: 'ğŸ´ Faction Tracking',
        value: [
          '`/track faction <id>` - Add faction',
          '  `offline`: Hours before alert (default: 24)',
          '`/remove <id>` - Stop tracking',
        ].join('\n'),
        inline: false,
      },
      {
        name: 'ğŸ”” Personal Alerts',
        value: [
          '`/alerts` - Configure bar/cooldown/chain alerts',
          '',
          '**Quick Links:**',
          `[Drugs](${LINKS.drugs}) â€¢ [Boosters](${LINKS.boosters}) â€¢ [Alcohol](${LINKS.alcohol})`,
          `[Medical](${LINKS.medical}) â€¢ [Gym](${LINKS.gym}) â€¢ [Crimes](${LINKS.crimes})`,
        ].join('\n'),
        inline: false,
      },
      {
        name: 'ğŸ’¡ Tips',
        value: [
          'â€¢ **Times:** `5m`, `1h30m`, `90s`',
          'â€¢ **States:** `okay`, `hospital`, `jail`, `traveling`',
          'â€¢ Use button menus for easy configuration!',
        ].join('\n'),
        inline: false,
      },
    )
    .setFooter({ text: 'Most settings available through button menus!' })
    .setTimestamp();
}

function error(title, message, suggestion = null) {
  const embed = new EmbedBuilder()
    .setColor(COLORS.bad)
    .setTitle(`${EMOJI.error} ${title}`)
    .setDescription(message);
  
  if (suggestion) {
    embed.addFields({ name: 'ğŸ’¡ Suggestion', value: suggestion, inline: false });
  }
  
  return embed.setTimestamp();
}

function success(title, message) {
  return new EmbedBuilder()
    .setColor(COLORS.good)
    .setTitle(`${EMOJI.success} ${title}`)
    .setDescription(message)
    .setTimestamp();
}

function loading(message = 'Loading...') {
  return new EmbedBuilder()
    .setColor(COLORS.brand)
    .setDescription(`${EMOJI.loading} ${message}`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

module.exports = {
  // Dashboard
  dashboard,
  
  // Users
  userList,
  userStatus,
  
  // Factions
  factionList,
  
  // Alerts config
  alertsConfig,
  
  // Notifications - User
  stateChange,
  preAlert,
  
  // Notifications - Personal
  barFull,
  cooldownReady,
  chainAlert,
  addictionRehabAlert,
  racingJoinReminder,
  
  // Notifications - Faction
  factionMemberChange,
  factionJoinLeave,
  factionOffline,
  factionDaily,
  factionMilestone,
  
  // Utility
  help,
  error,
  success,
  loading,
};

================================================================================

File: src/discord/handlers.js
----------------------------------------
const config = require('../config');
const store = require('../services/store');
const api = require('../services/api');
const Embeds = require('./embeds');
const Components = require('./components');
const Modals = require('./modals');
const { parseStates, parseTimes, parseTime, formatTime } = require('../utils');
const { createTravelInfo } = require('../utils/travel');
const { COLORS } = require('../config/constants');
const { EmbedBuilder } = require('discord.js');

// Forward declaration - will be set by index.js
let startPollers = () => {};

function setPollerStarter(fn) {
  startPollers = fn;
}

/**
 * Handle all Discord interactions
 */
async function handleInteraction(interaction) {
  // Owner check
  if (interaction.user.id !== config.discord.ownerId) {
    return interaction.reply?.({ 
      content: 'ğŸ”’ This bot is owner-only.', 
      ephemeral: true,
    }).catch(() => {});
  }
  
  const ephemeral = interaction.inGuild();
  
  try {
    if (interaction.isModalSubmit()) {
      await handleModal(interaction, ephemeral);
    } else if (interaction.isButton()) {
      await handleButton(interaction);
    } else if (interaction.isStringSelectMenu()) {
      await handleSelect(interaction);
    } else if (interaction.isChatInputCommand()) {
      await handleCommand(interaction, ephemeral);
    }
  } catch (error) {
    console.error('[handler]', error);
    
    const msg = `âŒ ${error.message}`;
    
    if (interaction.deferred || interaction.replied) {
      await interaction.editReply(msg).catch(() => {});
    } else {
      await interaction.reply({ content: msg, ephemeral: true }).catch(() => {});
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODAL HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleModal(i, ephemeral) {
  const [, type, id] = i.customId.split(':');
  
  await i.deferUpdate().catch(() => i.deferReply({ ephemeral }));
  
  switch (type) {
    case 'adduser': {
      const userId = i.fields.getTextInputValue('user_id').trim();
      const states = parseStates(i.fields.getTextInputValue('states') || 'all');
      const warn = parseTimes(i.fields.getTextInputValue('warn'));
      
      if (store.watchers[userId]) {
        return i.editReply({ content: 'âš ï¸ Already tracking this user' });
      }
      
      let profile;
      try {
        profile = await api.getProfile(userId);
      } catch {
        return i.editReply({ content: 'âŒ User not found' });
      }
      
      store.watchers[userId] = {
        name: profile.name,
        states,
        preTimesSec: warn.length ? warn : undefined,
        enabled: true,
        lastState: profile.status?.state || 'Okay',
        preFired: {},
        travel: profile.status?.state === 'Traveling' 
          ? createTravelInfo(profile.status) 
          : null,
      };
      
      store.save('add-user');
      startPollers();
      
      return i.editReply({
        content: `âœ… Now tracking **${profile.name}**`,
        embeds: [Embeds.userStatus(userId, profile, store.watchers[userId])],
        components: Components.userConfig(userId),
      });
    }
    
    case 'addfaction': {
      const fid = i.fields.getTextInputValue('faction_id').trim();
      const states = parseStates(i.fields.getTextInputValue('states') || 'all');
      const offline = parseInt(i.fields.getTextInputValue('offline')) || config.defaults.offlineHours;
      
      if (store.factions.items[fid]) {
        return i.editReply({ content: 'âš ï¸ Already tracking this faction' });
      }
      
      let data;
      try {
        data = await api.getFaction(fid);
      } catch {
        return i.editReply({ content: 'âŒ Faction not found' });
      }
      
      store.factions.items[fid] = {
        id: fid,
        name: data.name,
        tag: data.tag,
        enabled: true,
        states,
        members: {},
        offline: { enabled: true, hours: offline },
        daily: { enabled: true },
      };
      
      store.save('add-faction');
      startPollers();
      
      return i.editReply({
        content: `âœ… Now tracking **${data.name}** (${Object.keys(data.members || {}).length} members)`,
        components: Components.factionConfig(fid),
      });
    }
    
    case 'chain': {
      const min = parseInt(i.fields.getTextInputValue('min')) || 10;
      const thresholds = parseTimes(i.fields.getTextInputValue('thresholds'));
      
      store.self.chain.min = min;
      if (thresholds.length) {
        store.self.chain.thresholds = thresholds;
      }
      
      store.save('chain-config');
      
      return i.editReply({
        embeds: [Embeds.alertsConfig()],
        components: Components.alertsButtons(),
      });
    }
    
    case 'addiction': {
      const threshold = parseInt(i.fields.getTextInputValue('threshold'));
      const hour = parseInt(i.fields.getTextInputValue('hour'));
      const minute = parseInt(i.fields.getTextInputValue('minute'));
      
      if (!isNaN(threshold)) {
        store.self.addiction.threshold = threshold;
      }
      
      if (!store.self.addiction.dailyCheck) {
        store.self.addiction.dailyCheck = { enabled: true, hour: 18, minute: 10 };
      }
      
      if (!isNaN(hour) && hour >= 0 && hour <= 23) {
        store.self.addiction.dailyCheck.hour = hour;
      }
      
      if (!isNaN(minute) && minute >= 0 && minute <= 59) {
        store.self.addiction.dailyCheck.minute = minute;
      }
      
      store.save('addiction-config');
      
      // Reschedule the addiction check with new time
      const { scheduleAddictionCheck } = require('../pollers');
      scheduleAddictionCheck();
      
      return i.editReply({
        embeds: [Embeds.alertsConfig()],
        components: Components.alertsButtons(),
      });
    }
    
    case 'userwarn': {
      const warn = parseTimes(i.fields.getTextInputValue('warn'));
      const cfg = store.watchers[id];
      
      if (cfg) {
        cfg.preTimesSec = warn.length ? warn : undefined;
        store.save('user-warn');
      }
      
      const profile = await api.getProfile(id).catch(() => null);
      
      return i.editReply({
        embeds: [Embeds.userStatus(id, profile, cfg)],
        components: Components.userConfig(id),
      });
    }
    
    case 'factionwarn': {
      const warn = parseTimes(i.fields.getTextInputValue('warn'));
      const f = store.factions.items[id];
      
      if (f) {
        f.preTimesSec = warn.length ? warn : undefined;
        store.save('faction-warn');
      }
      
      return i.editReply({
        embeds: [Embeds.factionList()],
        components: Components.factionConfig(id),
      });
    }
    
    case 'factionoffline': {
      const hours = parseInt(i.fields.getTextInputValue('hours')) || config.defaults.offlineHours;
      const f = store.factions.items[id];
      
      if (f) {
        f.offline = f.offline || {};
        f.offline.hours = hours;
        store.save('faction-offline');
      }
      
      return i.editReply({
        components: Components.factionConfig(id),
      });
    }
    
    case 'delay': {
      const time = parseTime(i.fields.getTextInputValue('time')) || 0;
      const cfg = store.watchers[id];
      
      if (cfg?.travel) {
        cfg.travel.earliest = (cfg.travel.earliest || 0) + time;
        cfg.travel.latest = (cfg.travel.latest || 0) + time;
        store.save('delay');
      }
      
      const profile = await api.getProfile(id).catch(() => null);
      
      return i.editReply({
        content: `âœ… Added ${formatTime(time)} delay`,
        embeds: [Embeds.userStatus(id, profile, cfg)],
      });
    }
    
    default:
      return i.editReply({ content: 'âŒ Unknown modal type' });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUTTON HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleButton(i) {
  const [action, type, id] = i.customId.split(':');
  
  // Dashboard navigation
  if (action === 'dash') {
    await i.deferUpdate();
    
    switch (type) {
      case 'main':
      case 'refresh':
        return i.editReply({
          embeds: [Embeds.dashboard()],
          components: Components.dashboardButtons(),
        });
      
      case 'users':
        return i.editReply({
          embeds: [Embeds.userList()],
          components: Components.userListMenu(),
        });
      
      case 'factions':
        return i.editReply({
          embeds: [Embeds.factionList()],
          components: Components.factionListMenu(),
        });
      
      case 'alerts':
        return i.editReply({
          embeds: [Embeds.alertsConfig()],
          components: Components.alertsButtons(),
        });
    }
  }
  
  // Modal triggers
  if (action === 'modal') {
    switch (type) {
      case 'adduser':
        return i.showModal(Modals.addUser());
      case 'addfaction':
        return i.showModal(Modals.addFaction());
      case 'chain':
        return i.showModal(Modals.chainConfig());
      case 'addiction':
        return i.showModal(Modals.addictionConfig());
      case 'userwarn':
        return i.showModal(Modals.userWarn(id));
      case 'factionwarn':
        return i.showModal(Modals.factionWarn(id));
      case 'factionoffline':
        return i.showModal(Modals.factionOffline(id));
      case 'delay':
        return i.showModal(Modals.delay(id));
    }
  }
  
  // Toggle actions
  if (action === 'toggle') {
    await i.deferUpdate();
    
    switch (type) {
      case 'bar': {
        store.self.bars[id] = !store.self.bars[id];
        store.save('toggle-bar');
        startPollers();
        
        return i.editReply({
          embeds: [Embeds.alertsConfig()],
          components: Components.alertsButtons(),
        });
      }
      
      case 'cd': {
        store.self.cooldowns[id] = !store.self.cooldowns[id];
        store.save('toggle-cd');
        startPollers();
        
        return i.editReply({
          embeds: [Embeds.alertsConfig()],
          components: Components.alertsButtons(),
        });
      }
      
      case 'chain': {
        store.self.chain.enabled = !store.self.chain.enabled;
        store.save('toggle-chain');
        startPollers();
        
        return i.editReply({
          embeds: [Embeds.alertsConfig()],
          components: Components.alertsButtons(),
        });
      }
      
      case 'addiction': {
        const { addiction } = store.self;
        if (!addiction.dailyCheck) {
          addiction.dailyCheck = { enabled: true, hour: 18, minute: 10 };
        }
        addiction.dailyCheck.enabled = !addiction.dailyCheck.enabled;
        store.save('toggle-addiction');
        
        // Schedule/reschedule the addiction check
        const { scheduleAddictionCheck } = require('../pollers');
        scheduleAddictionCheck();
        
        return i.editReply({
          embeds: [Embeds.alertsConfig()],
          components: Components.alertsButtons(),
        });
      }
      
      case 'racing': {
        store.self.racing.enabled = !store.self.racing.enabled;
        store.save('toggle-racing');
        startPollers();
        
        return i.editReply({
          embeds: [Embeds.alertsConfig()],
          components: Components.alertsButtons(),
        });
      }
      
      case 'user': {
        const cfg = store.watchers[id];
        if (cfg) {
          cfg.enabled = cfg.enabled === false;
        }
        store.save('toggle-user');
        startPollers();
        
        const profile = await api.getProfile(id).catch(() => null);
        
        return i.editReply({
          embeds: [Embeds.userStatus(id, profile, cfg)],
          components: Components.userConfig(id),
        });
      }
      
      case 'faction': {
        const f = store.factions.items[id];
        if (f) {
          f.enabled = f.enabled === false;
        }
        store.save('toggle-faction');
        startPollers();
        
        return i.editReply({
          components: Components.factionConfig(id),
        });
      }
      
      case 'foffline': {
        const f = store.factions.items[id];
        if (f) {
          f.offline = f.offline || {};
          f.offline.enabled = f.offline.enabled === false;
        }
        store.save('toggle-foffline');
        
        return i.editReply({
          components: Components.factionConfig(id),
        });
      }
      
      case 'fdaily': {
        const f = store.factions.items[id];
        if (f) {
          f.daily = f.daily || {};
          f.daily.enabled = f.daily.enabled === false;
        }
        store.save('toggle-fdaily');
        
        return i.editReply({
          components: Components.factionConfig(id),
        });
      }
    }
  }
  
  // Remove actions
  if (action === 'remove') {
    await i.deferUpdate();
    
    if (type === 'user') {
      delete store.watchers[id];
      store.save('remove-user');
      startPollers();
      
      return i.editReply({
        content: 'âœ… User removed',
        embeds: [Embeds.userList()],
        components: Components.userListMenu(),
      });
    }
    
    if (type === 'faction') {
      delete store.factions.items[id];
      store.save('remove-faction');
      startPollers();
      
      return i.editReply({
        content: 'âœ… Faction removed',
        embeds: [Embeds.factionList()],
        components: Components.factionListMenu(),
      });
    }
  }
  
  // Refresh actions
  if (action === 'refresh') {
    await i.deferUpdate();
    
    if (type === 'user') {
      const cfg = store.watchers[id];
      const profile = await api.getProfile(id).catch(() => null);
      
      if (profile && cfg) {
        cfg.name = profile.name;
        cfg.lastState = profile.status?.state;
        if (profile.status?.state === 'Traveling') {
          cfg.travel = createTravelInfo(profile.status);
        }
        store.save('refresh');
      }
      
      return i.editReply({
        embeds: [Embeds.userStatus(id, profile, cfg)],
        components: Components.userConfig(id),
      });
    }
  }
  
  // Alerts refresh
  if (action === 'alerts' && type === 'refresh') {
    await i.deferUpdate();
    
    // Import and call poll functions
    const { pollBars, pollCooldowns } = require('../pollers/self');
    await pollBars().catch(() => {});
    await pollCooldowns().catch(() => {});
    
    return i.editReply({
      embeds: [Embeds.alertsConfig()],
      components: Components.alertsButtons(),
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SELECT MENU HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleSelect(i) {
  await i.deferUpdate();
  
  const [type, id] = i.customId.split(':');
  
  if (type === 'select') {
    if (id === 'user') {
      const userId = i.values[0];
      const cfg = store.watchers[userId];
      const profile = await api.getProfile(userId).catch(() => null);
      
      return i.editReply({
        embeds: [Embeds.userStatus(userId, profile, cfg)],
        components: Components.userConfig(userId),
      });
    }
    
    if (id === 'faction') {
      const fid = i.values[0];
      
      return i.editReply({
        components: Components.factionConfig(fid),
      });
    }
  }
  
  // State selection for users
  if (type === 'states') {
    const cfg = store.watchers[id];
    if (cfg) {
      cfg.states = i.values;
    }
    store.save('states');
    
    const profile = await api.getProfile(id).catch(() => null);
    
    return i.editReply({
      embeds: [Embeds.userStatus(id, profile, cfg)],
      components: Components.userConfig(id),
    });
  }
  
  // State selection for factions
  if (type === 'fstates') {
    const f = store.factions.items[id];
    if (f) {
      f.states = i.values;
    }
    store.save('fstates');
    
    return i.editReply({
      components: Components.factionConfig(id),
    });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SLASH COMMAND HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleCommand(i, ephemeral) {
  await i.deferReply({ ephemeral });
  
  switch (i.commandName) {
    case 'dashboard':
      return i.editReply({
        embeds: [Embeds.dashboard()],
        components: Components.dashboardButtons(),
      });
    
    case 'help':
      return i.editReply({
        embeds: [Embeds.help()],
      });
    
    case 'alerts':
      return i.editReply({
        embeds: [Embeds.alertsConfig()],
        components: Components.alertsButtons(),
      });
    
    case 'track':
      return handleTrackCommand(i);
    
    case 'status':
      return handleStatusCommand(i);
    
    case 'remove':
      return handleRemoveCommand(i);
    
    case 'delay':
      return handleDelayCommand(i);
    
    default:
      return i.editReply({ content: 'âŒ Unknown command' });
  }
}

async function handleTrackCommand(i) {
  const sub = i.options.getSubcommand();
  
  if (sub === 'user') {
    const userId = String(i.options.getInteger('id'));
    const states = parseStates(i.options.getString('alerts'));
    const warn = parseTimes(i.options.getString('warn'));
    
    if (store.watchers[userId]) {
      return i.editReply({ content: 'âš ï¸ Already tracking this user' });
    }
    
    let profile;
    try {
      profile = await api.getProfile(userId);
    } catch {
      return i.editReply({ content: 'âŒ User not found' });
    }
    
    store.watchers[userId] = {
      name: profile.name,
      states,
      preTimesSec: warn.length ? warn : undefined,
      enabled: true,
      lastState: profile.status?.state || 'Okay',
      preFired: {},
      travel: profile.status?.state === 'Traveling' 
        ? createTravelInfo(profile.status) 
        : null,
    };
    
    store.save('add');
    startPollers();
    
    return i.editReply({
      embeds: [Embeds.userStatus(userId, profile, store.watchers[userId])],
      components: Components.userConfig(userId),
    });
  }
  
  if (sub === 'faction') {
    const fid = String(i.options.getInteger('id'));
    const states = parseStates(i.options.getString('alerts'));
    const warn = parseTimes(i.options.getString('warn'));
    const offline = i.options.getInteger('offline') || config.defaults.offlineHours;
    
    if (store.factions.items[fid]) {
      return i.editReply({ content: 'âš ï¸ Already tracking this faction' });
    }
    
    let data;
    try {
      data = await api.getFaction(fid);
    } catch {
      return i.editReply({ content: 'âŒ Faction not found' });
    }
    
    store.factions.items[fid] = {
      id: fid,
      name: data.name,
      enabled: true,
      states,
      preTimesSec: warn.length ? warn : undefined,
      members: {},
      offline: { enabled: true, hours: offline },
      daily: { enabled: true },
    };
    
    store.save('add-faction');
    startPollers();
    
    return i.editReply({
      content: `âœ… Tracking **${data.name}**`,
      components: Components.factionConfig(fid),
    });
  }
}

async function handleStatusCommand(i) {
  const id = String(i.options.getInteger('id'));
  
  // Try user first
  try {
    const profile = await api.getProfile(id);
    const cfg = store.watchers[id];
    
    return i.editReply({
      embeds: [Embeds.userStatus(id, profile, cfg)],
      components: cfg 
        ? Components.userConfig(id) 
        : Components.quickActions(id, profile.status?.state),
    });
  } catch {}
  
  // Try faction
  try {
    const data = await api.getFaction(id);
    const f = store.factions.items[id];
    const memberCount = Object.keys(data.members || {}).length;
    
    const embed = new EmbedBuilder()
      .setColor(COLORS.brand)
      .setTitle(`ğŸ´ ${data.name}`)
      .addFields(
        { name: 'Members', value: String(memberCount), inline: true },
        { name: 'Respect', value: Number(data.respect || 0).toLocaleString(), inline: true },
        { 
          name: 'Tracking', 
          value: f 
            ? (f.enabled === false ? 'ğŸ”´ Paused' : 'ğŸŸ¢ Active') 
            : 'Not tracked', 
          inline: true,
        },
      );
    
    return i.editReply({
      embeds: [embed],
      components: f ? Components.factionConfig(id) : [],
    });
  } catch {}
  
  return i.editReply({ content: 'âŒ Not found' });
}

async function handleRemoveCommand(i) {
  const id = String(i.options.getInteger('id'));
  
  if (store.watchers[id]) {
    delete store.watchers[id];
    store.save('remove');
    startPollers();
    return i.editReply({ content: 'âœ… User removed' });
  }
  
  if (store.factions.items[id]) {
    delete store.factions.items[id];
    store.save('remove');
    startPollers();
    return i.editReply({ content: 'âœ… Faction removed' });
  }
  
  return i.editReply({ content: 'âŒ Not found' });
}

async function handleDelayCommand(i) {
  const id = String(i.options.getInteger('id'));
  const time = parseTime(i.options.getString('time')) || 0;
  
  const cfg = store.watchers[id];
  if (!cfg?.travel) {
    return i.editReply({ content: 'âŒ User not traveling' });
  }
  
  cfg.travel.earliest = (cfg.travel.earliest || 0) + time;
  cfg.travel.latest = (cfg.travel.latest || 0) + time;
  store.save('delay');
  
  const profile = await api.getProfile(id).catch(() => null);
  
  return i.editReply({
    content: `âœ… Added ${formatTime(time)} delay`,
    embeds: [Embeds.userStatus(id, profile, cfg)],
  });
}

module.exports = {
  handleInteraction,
  setPollerStarter,
};

================================================================================

File: src/discord/modals.js
----------------------------------------
const {
    ModalBuilder,
    ActionRowBuilder,
    TextInputBuilder,
    TextInputStyle,
  } = require('discord.js');
  const store = require('../services/store');
  const { formatTime } = require('../utils');
  
  function addUser() {
    return new ModalBuilder()
      .setCustomId('modal:adduser:submit')
      .setTitle('Add User to Track')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('user_id')
            .setLabel('Torn User ID')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setPlaceholder('e.g., 12345')
            .setMinLength(1)
            .setMaxLength(10),
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('states')
            .setLabel('Alert States (optional)')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('jail, hospital, okay, traveling (or "all")'),
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('warn')
            .setLabel('Early Warnings (optional)')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('e.g., 5m, 2m, 30s'),
        ),
      );
  }
  
  function addFaction() {
    return new ModalBuilder()
      .setCustomId('modal:addfaction:submit')
      .setTitle('Add Faction to Track')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('faction_id')
            .setLabel('Faction ID')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setPlaceholder('e.g., 12345')
            .setMinLength(1)
            .setMaxLength(10),
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('states')
            .setLabel('Alert States (optional)')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('jail, hospital, okay, traveling (or "all")'),
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('offline')
            .setLabel('Offline Alert Hours (optional)')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('e.g., 24'),
        ),
      );
  }
  
  function chainConfig() {
    const chain = store.self.chain;
    
    return new ModalBuilder()
      .setCustomId('modal:chain:submit')
      .setTitle('Chain Alert Settings')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('min')
            .setLabel('Minimum Chain Length')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('e.g., 10')
            .setValue(String(chain.min || 10)),
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('thresholds')
            .setLabel('Alert Times (comma-separated)')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('e.g., 2m, 1m, 30s')
            .setValue(chain.thresholds?.map(formatTime).join(', ') || '2m, 1m, 30s'),
        ),
      );
  }
  
  function userWarn(userId) {
    const cfg = store.watchers[userId] || {};
    
    return new ModalBuilder()
      .setCustomId(`modal:userwarn:${userId}:submit`)
      .setTitle('Early Warning Alerts')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('warn')
            .setLabel('Alert before state ends')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('e.g., 5m, 2m, 30s')
            .setValue(cfg.preTimesSec?.map(formatTime).join(', ') || ''),
        ),
      );
  }
  
  function factionWarn(factionId) {
    const f = store.factions.items[factionId] || {};
    
    return new ModalBuilder()
      .setCustomId(`modal:factionwarn:${factionId}:submit`)
      .setTitle('Early Warning Alerts')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('warn')
            .setLabel('Alert before state ends')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('e.g., 5m, 2m, 30s')
            .setValue(f.preTimesSec?.map(formatTime).join(', ') || ''),
        ),
      );
  }
  
  function factionOffline(factionId) {
    const f = store.factions.items[factionId] || {};
    
    return new ModalBuilder()
      .setCustomId(`modal:factionoffline:${factionId}:submit`)
      .setTitle('Offline Alert Settings')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('hours')
            .setLabel('Hours before alert')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('e.g., 24')
            .setValue(String(f.offline?.hours || 24)),
        ),
      );
  }
  
  function delay(userId) {
    return new ModalBuilder()
      .setCustomId(`modal:delay:${userId}:submit`)
      .setTitle('Add Travel Delay')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('time')
            .setLabel('Delay Time')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setPlaceholder('e.g., 5m, 30s, 1h'),
        ),
      );
  }
  
  function addictionConfig() {
    const addiction = store.self.addiction;
    const dailyCheck = addiction.dailyCheck || {};
    
    return new ModalBuilder()
      .setCustomId('modal:addiction:submit')
      .setTitle('Addiction Check Settings')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('threshold')
            .setLabel('Addiction Threshold')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('e.g., -5 (negative number)')
            .setValue(String(addiction.threshold ?? -5)),
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('hour')
            .setLabel('Check Hour (0-23, Torn time/UTC)')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('e.g., 18 for 6pm')
            .setValue(String(dailyCheck.hour ?? 18)),
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder()
            .setCustomId('minute')
            .setLabel('Check Minute (0-59)')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setPlaceholder('e.g., 10')
            .setValue(String(dailyCheck.minute ?? 10)),
        ),
      );
  }
  
  module.exports = {
    addUser,
    addFaction,
    chainConfig,
    userWarn,
    factionWarn,
    factionOffline,
    delay,
    addictionConfig,
  };

================================================================================

File: src/index.js
----------------------------------------
require('dotenv').config();

const express = require('express');
const { Client, GatewayIntentBits, Partials } = require('discord.js');

const config = require('./config');
const store = require('./services/store');
const api = require('./services/api');
const { setClient } = require('./services/notify');
const { handleInteraction, setPollerStarter } = require('./discord/handlers');
const commands = require('./discord/commands');
const { startPollers, stopPollers, scheduleDailyDigest, scheduleAddictionCheck } = require('./pollers');
const { createTravelInfo } = require('./utils/travel');
const { sleep } = require('./utils/format');
const { STATES } = require('./config/constants');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPRESS SERVER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const app = express();

app.get('/', (req, res) => res.send('Torn Tracker Online'));

app.get('/healthz', (req, res) => {
  const stats = store.getStats();
  res.json({
    ok: true,
    uptime: process.uptime(),
    stats,
  });
});

app.get('/stats', (req, res) => {
  res.json(store.getStats());
});

app.listen(config.port, () => {
  console.log(`[web] Listening on port ${config.port}`);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DISCORD CLIENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.DirectMessages,
  ],
  partials: [Partials.Channel],
});

// Set client for notifications
setClient(client);

// Set poller starter for handlers
setPollerStarter(startPollers);

// Handle interactions
client.on('interactionCreate', handleInteraction);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STARTUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function initialize() {
  // Load stored data
  store.load();
  
  // Seed from environment if empty
  seedFromEnv();
  
  // Validate API key
  const keyCheck = await api.validateKey();
  if (!keyCheck.valid) {
    console.error('[api] Invalid API key:', keyCheck.error);
    process.exit(1);
  }
  console.log(`[api] Connected as ${keyCheck.name} (Level ${keyCheck.level})`);
}

function seedFromEnv() {
  // Seed users from env
  if (!Object.keys(store.watchers).length && config.torn.userIds) {
    const ids = config.torn.userIds.split(',').filter(Boolean);
    
    for (const id of ids) {
      const trimmed = id.trim();
      store.watchers[trimmed] = {
        name: `User ${trimmed}`,
        states: [...STATES],
        enabled: true,
        lastState: null,
        preFired: {},
      };
    }
    
    if (ids.length) {
      console.log(`[seed] Added ${ids.length} users from env`);
      store.save('seed-users');
    }
  }
  
  // Seed factions from env
  if (!Object.keys(store.factions.items).length && config.torn.factionIds) {
    const ids = config.torn.factionIds.split(',').filter(Boolean);
    
    for (const id of ids) {
      const trimmed = id.trim();
      store.factions.items[trimmed] = {
        id: trimmed,
        name: `Faction ${trimmed}`,
        states: [...STATES],
        enabled: true,
        members: {},
        offline: { enabled: true, hours: config.defaults.offlineHours },
        daily: { enabled: true },
      };
    }
    
    if (ids.length) {
      console.log(`[seed] Added ${ids.length} factions from env`);
      store.save('seed-factions');
    }
  }
}

async function primeBaselines() {
  console.log('[prime] Establishing baselines...');
  
  for (const [id, cfg] of Object.entries(store.watchers)) {
    if (cfg.lastState) continue;
    
    try {
      const profile = await api.getProfile(id);
      
      cfg.name = profile.name;
      cfg.lastState = profile.status?.state || 'Okay';
      
      if (profile.status?.state === 'Traveling') {
        cfg.travel = createTravelInfo(profile.status);
      }
      
      console.log(`[prime] ${cfg.name}: ${cfg.lastState}`);
      await sleep(500);
    } catch (error) {
      console.warn(`[prime] Failed for ${id}: ${error.message}`);
    }
  }
  
  store.save('primed');
}

async function registerCommands() {
  try {
    // Guild commands (instant)
    if (config.discord.guildId) {
      const guild = await client.guilds.fetch(config.discord.guildId);
      await guild.commands.set(commands);
      console.log(`[cmd] Registered ${commands.length} guild commands`);
    }
    
    // Global commands (may take up to an hour to propagate)
    await client.application.commands.set(commands);
    console.log(`[cmd] Registered ${commands.length} global commands`);
  } catch (error) {
    console.warn('[cmd] Failed to register commands:', error.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLIENT READY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

client.once('ready', async () => {
  console.log(`[discord] Logged in as ${client.user.tag}`);
  
  await registerCommands();
  await primeBaselines();
  
  // Start all pollers
  startPollers();
  
  // Schedule daily faction digest
  scheduleDailyDigest();
  
  // Schedule daily addiction check
  scheduleAddictionCheck();
  
  // Status summary
  const stats = store.getStats();
  console.log(
    `[ready] Tracking ${stats.users.active} users, ` +
    `${stats.factions.active} factions (${stats.factions.members} members)`
  );
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ERROR HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

client.on('error', error => {
  console.error('[discord] Error:', error.message);
});

process.on('unhandledRejection', error => {
  console.error('[unhandled]', error);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GRACEFUL SHUTDOWN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function shutdown(signal) {
  console.log(`\n[${signal}] Shutting down...`);
  
  stopPollers();
  store.saveSync();
  
  client.destroy();
  
  setTimeout(() => process.exit(0), 500);
}

process.on('SIGINT', () => shutdown('SIGINT'));
process.on('SIGTERM', () => shutdown('SIGTERM'));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// START
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(async () => {
  try {
    await initialize();
    await client.login(config.discord.token);
  } catch (error) {
    console.error('[fatal]', error);
    process.exit(1);
  }
})();

================================================================================

File: src/pollers/company.js
----------------------------------------
const store = require('../services/store');
const api = require('../services/api');
const { notify } = require('../services/notify');
const Embeds = require('../discord/embeds');

/**
 * Poll company employees for addiction tracking
 */
async function pollCompany() {
  const { addiction } = store.self;
  
  if (!addiction.enabled) return;
  
  try {
    const ownerId = store.ownerId || api.getOwnerId();
    if (!ownerId) {
      console.warn('[company] Owner ID not set');
      return;
    }
    
    const employees = await api.getCompanyEmployees();
    const self = employees[String(ownerId)];
    
    if (!self) {
      console.warn('[company] Self not found in company employees');
      return;
    }
    
    const currentAddiction = self.effectiveness?.addiction ?? 0;
    const threshold = addiction.threshold ?? -5;
    const prevAddiction = addiction.last;
    
    // Update last known value
    addiction.last = currentAddiction;
    
    // Check if we need to alert
    const isBelowThreshold = currentAddiction <= threshold;
    const wasBelowThreshold = prevAddiction !== null && prevAddiction <= threshold;
    
    if (isBelowThreshold && !addiction.notified) {
      // Just dropped below threshold
      await notify(Embeds.addictionAlert(currentAddiction, threshold, self));
      addiction.notified = true;
      console.log(`[company] Addiction alert: ${currentAddiction} <= ${threshold}`);
    } else if (!isBelowThreshold && addiction.notified) {
      // Recovered above threshold
      await notify(Embeds.addictionRecovered(currentAddiction, threshold));
      addiction.notified = false;
      console.log(`[company] Addiction recovered: ${currentAddiction} > ${threshold}`);
    }
    
    store.save('company');
  } catch (error) {
    // Might not be in a company
    if (error.message.includes('company')) {
      console.log('[company] Not in a company');
    } else {
      console.warn('[company]', error.message);
    }
  }
}

module.exports = {
  pollCompany,
};

================================================================================

File: src/pollers/faction.js
----------------------------------------
const config = require('../config');
const store = require('../services/store');
const api = require('../services/api');
const { notify } = require('../services/notify');
const Embeds = require('../discord/embeds');
const { 
  createTravelInfo, 
  parseDestination, 
  parseTravelDirection,
} = require('../utils/travel');
const { sessionKey } = require('../utils/format');
const { checkPreAlerts } = require('./user');

/**
 * Poll a single faction
 */
async function pollFaction(factionId) {
  const fconf = store.factions.items[factionId];
  if (!fconf || fconf.enabled === false) return;
  
  let data;
  try {
    data = await api.getFaction(factionId);
  } catch (error) {
    console.warn(`[faction] Skipping ${fconf.name || factionId}: ${error.message}`);
    return;
  }
  
  const fName = data.name || `Faction ${factionId}`;
  
  // Update faction info
  fconf.name = data.name;
  fconf.tag = data.tag;
  fconf.lastCheck = Date.now();
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Respect Milestones
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  const currentRespect = Number(data.respect || 0);
  const prevStep = fconf.lastRespectStep ?? Math.floor((fconf.lastRespect || 0) / 100000);
  const currentStep = Math.floor(currentRespect / 100000);
  
  if (currentStep > prevStep && prevStep > 0) {
    await notify(Embeds.factionMilestone(fName, factionId, currentRespect));
  }
  
  fconf.lastRespect = currentRespect;
  fconf.lastRespectStep = currentStep;
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Member Tracking
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  const prevMembers = fconf.members || {};
  const newMembers = data.members;
  const watchStates = new Set(fconf.states || []);
  const offlineThreshold = (fconf.offline?.hours || config.defaults.offlineHours) * 3600;
  const nowSec = Math.floor(Date.now() / 1000);
  
  const prevIds = new Set(Object.keys(prevMembers));
  const newIds = new Set(Object.keys(newMembers));
  
  // Safety check: If >50% of members "left", likely API issue
  if (prevIds.size > 10) {
    const leftCount = [...prevIds].filter(id => !newIds.has(id)).length;
    const leftPct = leftCount / prevIds.size;
    
    if (leftPct > 0.5) {
      console.warn(
        `[faction] ${fName}: ${leftCount}/${prevIds.size} (${Math.round(leftPct * 100)}%) ` +
        `members "left" - likely API issue, skipping`
      );
      return;
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Member Joins
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  for (const uid of newIds) {
    if (!prevIds.has(uid)) {
      const member = newMembers[uid];
      console.log(`[faction] ${fName}: ${member.name} joined`);
      
      await notify(Embeds.factionJoinLeave('join', fName, factionId, uid, member.name));
      
      // Initialize cached member data
      prevMembers[uid] = {
        name: member.name,
        lastState: member.status?.state || 'Okay',
        lastActionTs: member.last_action?.timestamp,
        preFired: {},
        travel: null,
      };
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Member Leaves
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  for (const uid of prevIds) {
    if (!newIds.has(uid)) {
      const cached = prevMembers[uid];
      console.log(`[faction] ${fName}: ${cached?.name || uid} left`);
      
      await notify(Embeds.factionJoinLeave('leave', fName, factionId, uid, cached?.name || uid));
      
      delete prevMembers[uid];
    }
  }
  
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Member State Updates
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  for (const [uid, member] of Object.entries(newMembers)) {
    const cached = prevMembers[uid];
    if (!cached) continue; // Just joined, already handled
    
    const currentState = member.status?.state || 'Okay';
    const lastActionTs = Number(member.last_action?.timestamp || 0);
    const prevState = cached.lastState;
    
    // Same state
    if (currentState === prevState) {
      // Travel direction changes
      if (currentState === 'Traveling' && cached.travel) {
        const newDir = parseTravelDirection(member.status?.description);
        const newDest = parseDestination(member.status?.description);
        
        if (newDir !== cached.travel.direction || newDest !== cached.travel.destination) {
          cached.travel = createTravelInfo(member.status);
        }
      }
      
      // Pre-alerts for faction members
      if (fconf.preTimesSec?.length) {
        cached.preFired = cached.preFired || {};
        await checkPreAlerts(
          uid,
          `${member.name} (${fName})`,
          currentState,
          member.status,
          cached.travel,
          fconf.preTimesSec,
          cached.preFired
        );
      }
    } else {
      // State changed
      console.log(`[faction] ${fName}: ${member.name} ${prevState} â†’ ${currentState}`);
      
      const oldState = prevState;
      cached.lastState = currentState;
      cached.travel = currentState === 'Traveling' ? createTravelInfo(member.status) : null;
      
      // Reset pre-fired
      cached.preFired = cached.preFired || {};
      const key = sessionKey(currentState, member.status, cached.travel);
      if (key) {
        delete cached.preFired[key];
      }
      
      // Notify if state is watched
      if (watchStates.has(currentState)) {
        await notify(
          Embeds.factionMemberChange(fName, factionId, uid, member, oldState, currentState, cached.travel)
        );
      }
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Offline Check
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    if (fconf.offline?.enabled !== false && lastActionTs > 0) {
      const isOffline = (nowSec - lastActionTs) >= offlineThreshold;
      
      if (isOffline && !cached.offlineNotified) {
        await notify(
          Embeds.factionOffline(
            fName, 
            factionId, 
            uid, 
            member.name, 
            lastActionTs, 
            fconf.offline?.hours || config.defaults.offlineHours
          )
        );
        cached.offlineNotified = true;
      } else if (!isOffline) {
        cached.offlineNotified = false;
      }
    }
    
    // Update cached data
    cached.name = member.name;
    cached.lastActionTs = lastActionTs || cached.lastActionTs;
  }
  
  // Update members reference
  fconf.members = prevMembers;
  store.save('faction');
}

module.exports = {
  pollFaction,
};

================================================================================

File: src/pollers/index.js
----------------------------------------
const config = require('../config');
const store = require('../services/store');
const { pollUser } = require('./user');
const { pollFaction } = require('./faction');
const { startSelfPollers, stopSelfPollers } = require('./self');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POLLER CLASS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Poller {
  constructor(name) {
    this.name = name;
    this.items = [];
    this.index = 0;
    this.timer = null;
    this.ticking = false;
  }
  
  refresh(items) {
    this.items = items;
    if (this.index >= items.length) {
      this.index = 0;
    }
  }
  
  start(intervalMs, pollFn) {
    this.stop();
    
    if (!this.items.length) {
      console.log(`[${this.name}] No items to poll`);
      return;
    }
    
    console.log(`[${this.name}] Starting with ${this.items.length} items @ ${intervalMs}ms`);
    
    this.timer = setInterval(() => this.tick(pollFn), intervalMs);
    this.tick(pollFn); // Immediate first tick
  }
  
  stop() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
  
  async tick(pollFn) {
    if (this.ticking || !this.items.length) return;
    
    this.ticking = true;
    const item = this.items[this.index];
    this.index = (this.index + 1) % this.items.length;
    
    try {
      await pollFn(item);
    } catch (error) {
      const msg = error?.response?.status === 429 
        ? 'Rate limited' 
        : error.message;
      console.warn(`[${this.name}] ${item}: ${msg}`);
    } finally {
      this.ticking = false;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POLLER INSTANCES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const userPoller = new Poller('users');
const factionPoller = new Poller('factions');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// START/STOP ALL POLLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function startPollers() {
  // User polling
  const userIds = store.getActiveUsers();
  userPoller.refresh(userIds);
  userPoller.start(store.requestMs, pollUser);
  
  // Faction polling
  const factionIds = store.getActiveFactions();
  factionPoller.refresh(factionIds);
  factionPoller.start(store.factions.requestMs, pollFaction);
  
  // Self polling (bars, cooldowns, chain)
  startSelfPollers();
}

function stopPollers() {
  userPoller.stop();
  factionPoller.stop();
  stopSelfPollers();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DAILY DIGEST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let dailyTimer = null;

function scheduleDailyDigest() {
  const now = new Date();
  const next = new Date(Date.UTC(
    now.getUTCFullYear(),
    now.getUTCMonth(),
    now.getUTCDate() + 1,
    0, 0, 5 // 00:00:05 UTC
  ));
  
  const delay = next - now;
  
  clearTimeout(dailyTimer);
  dailyTimer = setTimeout(runDailyDigest, delay);
  
  console.log(`[daily] Scheduled for ${next.toISOString()}`);
}

async function runDailyDigest() {
  const api = require('../services/api');
  const { notify } = require('../services/notify');
  const Embeds = require('../discord/embeds');
  const { sleep } = require('../utils');
  
  console.log('[daily] Running digest...');
  
  for (const [fid, f] of Object.entries(store.factions.items)) {
    if (f.enabled === false || f.daily?.enabled === false) continue;
    
    try {
      const data = await api.getFaction(fid);
      const currentRespect = Number(data.respect || 0);
      
      f.daily = f.daily || {};
      
      if (f.daily.respectAtMidnight != null) {
        const delta = currentRespect - f.daily.respectAtMidnight;
        await notify(Embeds.factionDaily(data.name || fid, fid, delta, currentRespect));
      }
      
      f.daily.respectAtMidnight = currentRespect;
      store.save('daily');
      
      await sleep(1000);
    } catch (error) {
      console.warn(`[daily] ${fid}: ${error.message}`);
    }
  }
  
  // Schedule next
  scheduleDailyDigest();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DAILY ADDICTION CHECK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let addictionCheckTimer = null;

function scheduleAddictionCheck() {
  const { addiction } = store.self;
  
  if (!addiction.dailyCheck?.enabled) {
    return;
  }
  
  const now = new Date();
  const hour = addiction.dailyCheck.hour ?? 18;
  const minute = addiction.dailyCheck.minute ?? 10;
  
  // Calculate next occurrence at the specified hour:minute
  let next = new Date(Date.UTC(
    now.getUTCFullYear(),
    now.getUTCMonth(),
    now.getUTCDate(),
    hour,
    minute,
    0
  ));
  
  // If it's already past today's check time, schedule for tomorrow
  if (next <= now) {
    next = new Date(Date.UTC(
      now.getUTCFullYear(),
      now.getUTCMonth(),
      now.getUTCDate() + 1,
      hour,
      minute,
      0
    ));
  }
  
  const delay = next - now;
  
  clearTimeout(addictionCheckTimer);
  addictionCheckTimer = setTimeout(runAddictionCheck, delay);
  
  console.log(`[addiction-check] Scheduled for ${next.toISOString()}`);
}

async function runAddictionCheck() {
  const api = require('../services/api');
  const { notify } = require('../services/notify');
  const Embeds = require('../discord/embeds');
  
  const { addiction } = store.self;
  
  if (!addiction.dailyCheck?.enabled) {
    return;
  }
  
  console.log('[addiction-check] Running check...');
  
  try {
    const ownerId = await api.getOwnerId();
    if (!ownerId) {
      console.warn('[addiction-check] Owner ID not set');
      scheduleAddictionCheck();
      return;
    }
    
    const employees = await api.getCompanyEmployees();
    const self = employees[String(ownerId)];
    
    if (!self) {
      console.warn('[addiction-check] Self not found in company employees');
      scheduleAddictionCheck();
      return;
    }
    
    const currentAddiction = self.effectiveness?.addiction ?? 0;
    const threshold = addiction.threshold ?? -5;
    
    if (currentAddiction <= threshold) {
      await notify(Embeds.addictionRehabAlert(currentAddiction, threshold));
      console.log(`[addiction-check] Alert sent: ${currentAddiction} <= ${threshold}`);
    }
    
  } catch (error) {
    if (error.message.includes('company')) {
      console.log('[addiction-check] Not in a company');
    } else {
      console.warn('[addiction-check]', error.message);
    }
  }
  
  // Schedule next
  scheduleAddictionCheck();
}

module.exports = {
  Poller,
  userPoller,
  factionPoller,
  startPollers,
  stopPollers,
  scheduleDailyDigest,
  scheduleAddictionCheck,
};

================================================================================

File: src/pollers/self.js
----------------------------------------
const store = require('../services/store');
const api = require('../services/api');
const { notify } = require('../services/notify');
const Embeds = require('../discord/embeds');
const { BARS, COOLDOWNS } = require('../config/constants');
const config = require('../config');

let barsTimer = null;
let chainTimer = null;
let cooldownTimer = null;
let racingTimer = null;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BAR POLLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function pollBars() {
  try {
    const data = await api.getBars();
    const { self } = store.data;
    
    for (const bar of BARS) {
      if (!self.bars[bar]) continue;
      
      const current = data[bar];
      if (!current) continue;
      
      const isFull = current.current >= current.maximum;
      
      // Alert if just became full
      if (isFull && !self.bars.wasFull[bar]) {
        await notify(Embeds.barFull(bar, current));
      }
      
      self.bars.wasFull[bar] = isFull;
      self.bars.last[bar] = current;
    }
    
    // Also update chain data
    if (data.chain) {
      self.chain.last = {
        ...data.chain,
        updatedAt: Date.now(),
      };
    }
    
    store.save('bars');
  } catch (error) {
    console.warn('[bars]', error.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHAIN POLLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function pollChain() {
  try {
    const data = await api.getBars();
    const chain = data.chain;
    
    if (!chain) return;
    
    const { self } = store.data;
    const prevCount = self.chain.last?.current ?? 0;
    const currentCount = chain.current ?? 0;
    
    // Detect new chain epoch (chain reset or started)
    if (currentCount < prevCount || (prevCount === 0 && currentCount > 0)) {
      self.chain.epochId = (self.chain.epochId || 0) + 1;
      self.chain.fired[self.chain.epochId] = [];
    }
    
    self.chain.last = {
      ...chain,
      updatedAt: Date.now(),
    };
    
    // Check if we should alert
    if (!self.chain.enabled) return;
    if (currentCount < (self.chain.min || 10)) return;
    
    const epochFired = self.chain.fired[self.chain.epochId] || [];
    self.chain.fired[self.chain.epochId] = epochFired;
    
    const thresholds = (self.chain.thresholds || [120, 60, 30]).sort((a, b) => b - a);
    
    for (const threshold of thresholds) {
      if (!epochFired.includes(threshold) && chain.timeout <= threshold && chain.timeout >= 0) {
        epochFired.push(threshold);
        await notify(Embeds.chainAlert(chain, threshold));
      }
    }
    
    store.save('chain');
  } catch (error) {
    console.warn('[chain]', error.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COOLDOWN POLLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function pollCooldowns() {
  try {
    const cooldowns = await api.getCooldowns();
    const { self } = store.data;
    
    let soonestExpiry = Infinity;
    
    for (const cd of COOLDOWNS) {
      if (!self.cooldowns[cd]) continue;
      
      const prev = self.cooldowns.last[cd] || 0;
      const current = cooldowns[cd] ?? 0;
      
      self.cooldowns.last[cd] = current;
      
      // Alert if just became ready (was >0, now 0)
      if (prev > 0 && current <= 0) {
        await notify(Embeds.cooldownReady(cd));
      }
      
      // Track soonest expiry for smart scheduling
      if (current > 0) {
        soonestExpiry = Math.min(soonestExpiry, current);
      }
    }
    
    store.save('cooldowns');
    
    // Schedule next poll based on soonest expiry
    const nextPoll = soonestExpiry < Infinity 
      ? (soonestExpiry + 2) * 1000  // 2 second buffer
      : 30 * 60 * 1000;             // 30 minutes default
    
    scheduleCooldownPoll(nextPoll);
    
  } catch (error) {
    console.warn('[cooldowns]', error.message);
    // Retry in 5 minutes on error
    scheduleCooldownPoll(5 * 60 * 1000);
  }
}

function scheduleCooldownPoll(ms) {
  clearTimeout(cooldownTimer);
  
  const hasActiveCooldowns = COOLDOWNS.some(c => store.self.cooldowns[c]);
  if (!hasActiveCooldowns) return;
  
  cooldownTimer = setTimeout(pollCooldowns, Math.max(2000, ms));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RACING POLLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function pollRacing() {
  const { self } = store.data;
  
  if (!self.racing.enabled) return;
  
  try {
    const log = await api.getRacingLog();
    const { racing } = store.data.self;
    
    const events = Object.values(log);
    const now = Math.floor(Date.now() / 1000);
    
    // 1. Handle no logs (New account or API error)
    // Assume not in race, but ensure we don't spam if history is empty
    if (events.length === 0) {
      if ((now - (racing.lastNotify || 0)) > 60 * 60) {
        await notify(Embeds.racingJoinReminder());
        racing.lastNotify = now;
        racing.inRace = false;
        store.save('racing');
      }
      return;
    }
    
    // 2. Sort by timestamp descending (newest first)
    events.sort((a, b) => b.timestamp - a.timestamp);
    const latest = events[0];
    
    // 3. Check status based on latest event
    // Join codes: 8711 (Custom), 8715 (Official)
    const isRacing = latest.log === 8711 || latest.log === 8715;
    
    const prevInRace = racing.inRace;
    racing.inRace = isRacing;
    racing.lastChecked = now;
    
    // 4. Notify if we need to join a race
    if (!isRacing) {
      const lastNotify = racing.lastNotify || 0;
      
      // Notify if:
      // A. We were previously marked as racing (immediate notification upon finish)
      // B. We haven't notified in over 1 hour (periodic reminder)
      if (prevInRace || (now - lastNotify) > 60 * 60) {
        await notify(Embeds.racingJoinReminder());
        racing.lastNotify = now;
        console.log(`[racing] Race finished/idle. Last event: ${latest.title} (${latest.timestamp}). Sent reminder.`);
      }
    }
    
    store.save('racing');
  } catch (error) {
    console.warn('[racing]', error.message);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// START/STOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function startSelfPollers() {
  stopSelfPollers();
  
  const { self } = store.data;
  const hasBars = BARS.some(b => self.bars[b]);
  const hasChain = self.chain.enabled;
  const hasCooldowns = COOLDOWNS.some(c => self.cooldowns[c]);
  const hasRacing = self.racing.enabled;
  
  // Bars polling
  if (hasBars || hasChain) {
    console.log('[self] Starting bars polling');
    barsTimer = setInterval(pollBars, config.timing.barsMs);
    pollBars();
  }
  
  // Chain polling (more frequent)
  if (hasChain) {
    console.log('[self] Starting chain polling');
    chainTimer = setInterval(pollChain, config.timing.chainMs);
  }
  
  // Cooldowns polling (smart scheduling)
  if (hasCooldowns) {
    console.log('[self] Starting cooldowns polling');
    pollCooldowns();
  }
  
  // Racing polling (check every 5 minutes)
  if (hasRacing) {
    console.log('[self] Starting racing polling');
    racingTimer = setInterval(pollRacing, 5 * 60 * 1000);
    pollRacing(); // Initial check
  }
}

function stopSelfPollers() {
  clearInterval(barsTimer);
  clearInterval(chainTimer);
  clearTimeout(cooldownTimer);
  clearInterval(racingTimer);
  
  barsTimer = null;
  chainTimer = null;
  cooldownTimer = null;
  racingTimer = null;
}

module.exports = {
  pollBars,
  pollChain,
  pollCooldowns,
  pollRacing,
  startSelfPollers,
  stopSelfPollers,
};

================================================================================

File: src/pollers/user.js
----------------------------------------
const store = require('../services/store');
const api = require('../services/api');
const { notify } = require('../services/notify');
const Embeds = require('../discord/embeds');
const Components = require('../discord/components');
const { 
  createTravelInfo, 
  parseDestination, 
  parseTravelDirection,
} = require('../utils/travel');
const { sessionKey } = require('../utils/format');

/**
 * Check and fire pre-alerts for a user
 */
async function checkPreAlerts(userId, name, state, status, travel, preTimesSec, preFired) {
  if (!preTimesSec?.length) return;
  
  // Determine end time
  let endAt = null;
  if (state === 'Traveling' && travel?.earliest) {
    endAt = travel.earliest;
  } else if (['Jail', 'Hospital'].includes(state) && status?.until) {
    endAt = Number(status.until);
  }
  
  if (!endAt) return;
  
  const nowSec = Math.floor(Date.now() / 1000);
  const left = endAt - nowSec;
  
  if (left <= 0) return;
  
  const key = sessionKey(state, status, travel);
  if (!key) return;
  
  preFired[key] = preFired[key] || [];
  
  for (const threshold of preTimesSec) {
    if (left <= threshold && !preFired[key].includes(threshold)) {
      preFired[key].push(threshold);
      await notify(Embeds.preAlert(name, userId, state, endAt, left));
    }
  }
}

/**
 * Poll a single user
 */
async function pollUser(userId) {
  const cfg = store.watchers[userId];
  if (!cfg || cfg.enabled === false) return;
  
  let profile;
  try {
    profile = await api.getProfile(userId);
  } catch (error) {
    console.warn(`[user] Skipping ${cfg.name || userId}: ${error.message}`);
    return;
  }
  
  const status = profile.status;
  const state = status.state;
  const prevState = cfg.lastState;
  
  // Update name
  cfg.name = profile.name || cfg.name;
  cfg.lastCheck = Date.now();
  
  // First poll - establish baseline
  if (!prevState) {
    cfg.lastState = state;
    cfg.travel = state === 'Traveling' ? createTravelInfo(status) : null;
    store.save('baseline');
    console.log(`[user] Baseline: ${cfg.name} = ${state}`);
    return;
  }
  
  // Same state
  if (state === prevState) {
    // Pre-alerts
    cfg.preFired = cfg.preFired || {};
    await checkPreAlerts(
      userId, 
      cfg.name, 
      state, 
      status, 
      cfg.travel, 
      cfg.preTimesSec, 
      cfg.preFired
    );
    
    // Travel direction/destination changes
    if (state === 'Traveling' && cfg.travel) {
      const newDir = parseTravelDirection(status.description);
      const newDest = parseDestination(status.description);
      
      if (newDir !== cfg.travel.direction || newDest !== cfg.travel.destination) {
        cfg.travel = createTravelInfo(status);
        store.save('travel-update');
        
        if (cfg.states?.includes('Traveling')) {
          await notify(
            Embeds.stateChange(userId, cfg.name, 'Traveling', 'Traveling', status, cfg.travel)
          );
        }
      }
    }
    
    return;
  }
  
  // STATE CHANGED
  console.log(`[user] ${cfg.name}: ${prevState} â†’ ${state}`);
  
  const oldState = prevState;
  cfg.lastState = state;
  cfg.travel = state === 'Traveling' ? createTravelInfo(status) : null;
  
  // Reset pre-fired alerts for new session
  cfg.preFired = cfg.preFired || {};
  const key = sessionKey(state, status, cfg.travel);
  if (key) {
    delete cfg.preFired[key];
  }
  
  store.save('state-change');
  
  // Send notification if this state is tracked
  if (cfg.states?.includes(state)) {
    await notify(
      Embeds.stateChange(userId, cfg.name, oldState, state, status, cfg.travel),
      Components.quickActions(userId, state)
    );
  }
}

module.exports = {
  pollUser,
  checkPreAlerts,
};

================================================================================

File: src/services/api.js
----------------------------------------
const axios = require('axios');
const config = require('../config');

class TornAPI {
  constructor(apiKey) {
    this.key = apiKey;
    this.requestCount = 0;
    this.lastRequest = 0;
    
    // V2 API client
    this.v2 = axios.create({
      baseURL: 'https://api.torn.com/v2',
      timeout: 15000,
      params: { key: this.key, striptags: true },
    });
    
    // V1 API client
    this.v1 = axios.create({
      baseURL: 'https://api.torn.com',
      timeout: 15000,
      params: { key: this.key },
    });
    
    // Add response interceptors for error handling
    const errorHandler = this._handleError.bind(this);
    this.v1.interceptors.response.use(r => r, errorHandler);
    this.v2.interceptors.response.use(r => r, errorHandler);
  }

  _handleError(error) {
    if (error.response?.status === 429) {
      console.warn('[api] Rate limited, backing off...');
      throw new Error('Rate limited');
    }
    
    const tornError = error.response?.data?.error;
    if (tornError) {
      throw new Error(`API Error ${tornError.code}: ${tornError.error}`);
    }
    
    throw error;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // User Endpoints
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async getProfile(userId) {
    const { data } = await this.v2.get(`/user/${userId}/basic`);
    
    if (!data?.profile) {
      throw new Error(`Invalid profile response for ${userId}`);
    }
    
    if (!data.profile.status?.state) {
      throw new Error(`Missing status for ${userId}`);
    }
    
    return data.profile;
  }

  async getBars() {
    const { data } = await this.v1.get('/user/', {
      params: { selections: 'bars' },
    });
    
    if (!data) {
      throw new Error('Invalid bars response');
    }
    
    return data;
  }

  async getCooldowns() {
    const { data } = await this.v1.get('/user/', {
      params: { selections: 'cooldowns' },
    });
    
    if (!data?.cooldowns) {
      throw new Error('Invalid cooldowns response');
    }
    
    return data.cooldowns;
  }

  async getChain() {
    const { data } = await this.v1.get('/user/', {
      params: { selections: 'bars' },
    });
    
    return data?.chain || null;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Faction Endpoints
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async getFaction(factionId) {
    const { data } = await this.v1.get(`/faction/${factionId}`, {
      params: { selections: 'basic' },
    });
    
    if (!data) {
      throw new Error(`Invalid faction response for ${factionId}`);
    }
    
    if (!data.members || typeof data.members !== 'object') {
      throw new Error(`Missing members for faction ${factionId}`);
    }
    
    if (Object.keys(data.members).length === 0) {
      throw new Error(`Empty members for faction ${factionId}`);
    }
    
    return data;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Company Endpoints
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async getCompanyEmployees() {
    const { data } = await this.v1.get('/company/', {
      params: { selections: 'employees' },
    });
    
    if (!data?.company_employees) {
      throw new Error('Invalid company employees response');
    }
    
    return data.company_employees;
  }

  async getOwnerId() {
    const { data } = await this.v1.get('/user/', {
      params: { selections: 'basic' },
    });
    return data.player_id;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Racing Endpoints
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async getRacingLog() {
    const logIds = '8711,8715,8720,8721,8722,8730,8731';
    const { data } = await this.v1.get('/user/', {
      params: { 
        selections: 'log',
        log: logIds,
      },
    });
    
    if (!data?.log) {
      throw new Error('Invalid racing log response');
    }
    
    return data.log;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Utility
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async validateKey() {
    try {
      const { data } = await this.v1.get('/user/', {
        params: { selections: 'basic' },
      });
      return { valid: true, name: data.name, level: data.level };
    } catch (e) {
      return { valid: false, error: e.message };
    }
  }
}

// Singleton instance
const api = new TornAPI(config.torn.apiKey);

module.exports = api;

================================================================================

File: src/services/notify.js
----------------------------------------
const config = require('../config');

let discordClient = null;

/**
 * Set the Discord client for notifications
 */
function setClient(client) {
  discordClient = client;
}

/**
 * Send DM notification to owner
 */
async function notify(embeds, components = []) {
  if (!discordClient) {
    console.warn('[notify] Discord client not set');
    return false;
  }
  
  try {
    const user = await discordClient.users.fetch(config.discord.ownerId);
    
    await user.send({
      embeds: Array.isArray(embeds) ? embeds : [embeds],
      components,
    });
    
    return true;
  } catch (e) {
    console.error('[notify] Failed to send DM:', e.message);
    return false;
  }
}

/**
 * Send notification with retry
 */
async function notifyWithRetry(embeds, components = [], maxRetries = 2) {
  for (let i = 0; i <= maxRetries; i++) {
    const success = await notify(embeds, components);
    if (success) return true;
    
    if (i < maxRetries) {
      await new Promise(r => setTimeout(r, 1000 * (i + 1)));
    }
  }
  return false;
}

module.exports = {
  setClient,
  notify,
  notifyWithRetry,
};

================================================================================

File: src/services/store.js
----------------------------------------
const fs = require('fs');
const path = require('path');
const config = require('../config');
const { STATES, BARS, COOLDOWNS } = require('../config/constants');

class Store {
  constructor(filePath) {
    this.path = this._resolvePath(filePath);
    this.data = this._defaultData();
    this.saveTimer = null;
    this.saveDelay = 300; // ms
  }

  _resolvePath(target) {
    try {
      const dir = path.dirname(target);
      fs.mkdirSync(dir, { recursive: true });
      
      // Test write access
      const probe = `${target}.probe`;
      fs.writeFileSync(probe, '');
      fs.unlinkSync(probe);
      
      return target;
    } catch (e) {
      console.warn(`[store] Cannot write to ${target}, using /tmp`);
      return '/tmp/torn-tracker-store.json';
    }
  }

  _defaultData() {
    return {
      version: 2,
      requestMs: config.timing.requestMs,
      watchers: {},
      self: this._selfDefaults(),
      factions: {
        requestMs: config.timing.factionMs,
        items: {},
      },
    };
  }

  _selfDefaults() {
    return {
      bars: {
        ...Object.fromEntries(BARS.map(b => [b, false])),
        last: {},
        wasFull: {},
      },
      cooldowns: {
        ...Object.fromEntries(COOLDOWNS.map(c => [c, false])),
        last: {},
      },
      chain: {
        enabled: false,
        min: 10,
        thresholds: [120, 60, 30],
        last: {},
        epochId: 0,
        fired: {},
      },
      addiction: {
        enabled: false,
        threshold: -10,
        dailyCheck: {
          enabled: true,
          hour: 18, // 6:10pm Torn time (UTC)
          minute: 10,
        },
        last: null,
        notified: false,
      },
      racing: {
        enabled: false,
        lastChecked: null,
        inRace: false,
        lastRaceJoin: null,
        lastNotify: null,
      },
    };
  }

  load() {
    try {
      if (!fs.existsSync(this.path)) {
        console.log('[store] No existing data, starting fresh');
        return;
      }

      const raw = fs.readFileSync(this.path, 'utf8').trim();
      if (!raw) return;

      const loaded = JSON.parse(raw);
      
      // Merge with defaults to ensure all fields exist
      this.data = {
        ...this._defaultData(),
        ...loaded,
        self: {
          ...this._selfDefaults(),
          ...loaded.self,
          bars: {
            ...this._selfDefaults().bars,
            ...loaded.self?.bars,
          },
          cooldowns: {
            ...this._selfDefaults().cooldowns,
            ...loaded.self?.cooldowns,
          },
          chain: {
            ...this._selfDefaults().chain,
            ...loaded.self?.chain,
          },
          addiction: {
            ...this._selfDefaults().addiction,
            ...loaded.self?.addiction,
            dailyCheck: {
              ...this._selfDefaults().addiction.dailyCheck,
              ...loaded.self?.addiction?.dailyCheck,
            },
          },
          racing: {
            ...this._selfDefaults().racing,
            ...loaded.self?.racing,
          },
        },
        factions: {
          requestMs: config.timing.factionMs,
          items: {},
          ...loaded.factions,
        },
      };

      console.log(`[store] Loaded from ${this.path}`);
    } catch (e) {
      console.error('[store] Load failed:', e.message);
    }
  }

  save(reason = '') {
    clearTimeout(this.saveTimer);
    
    this.saveTimer = setTimeout(() => {
      try {
        const tmp = `${this.path}.tmp`;
        const json = JSON.stringify(this.data, null, 2);
        
        fs.writeFileSync(tmp, json);
        fs.renameSync(tmp, this.path);
        
        if (reason) {
          console.log(`[store] Saved (${reason})`);
        }
      } catch (e) {
        console.error('[store] Save failed:', e.message);
      }
    }, this.saveDelay);
  }

  saveSync() {
    clearTimeout(this.saveTimer);
    try {
      fs.writeFileSync(this.path, JSON.stringify(this.data, null, 2));
    } catch (e) {
      console.error('[store] Sync save failed:', e.message);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Accessors
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  get watchers() {
    return this.data.watchers;
  }

  get self() {
    return this.data.self;
  }

  get factions() {
    return this.data.factions;
  }

  get requestMs() {
    return this.data.requestMs;
  }

  set requestMs(value) {
    this.data.requestMs = value;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // User Methods
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  getUser(userId) {
    return this.watchers[userId];
  }

  setUser(userId, data) {
    this.watchers[userId] = data;
    this.save('user-update');
  }

  removeUser(userId) {
    delete this.watchers[userId];
    this.save('user-remove');
  }

  getActiveUsers() {
    return Object.entries(this.watchers)
      .filter(([, cfg]) => cfg?.enabled !== false)
      .map(([id]) => id);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Faction Methods
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  getFaction(factionId) {
    return this.factions.items[factionId];
  }

  setFaction(factionId, data) {
    this.factions.items[factionId] = data;
    this.save('faction-update');
  }

  removeFaction(factionId) {
    delete this.factions.items[factionId];
    this.save('faction-remove');
  }

  getActiveFactions() {
    return Object.entries(this.factions.items)
      .filter(([, f]) => f?.enabled !== false)
      .map(([id]) => id);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Stats
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  getStats() {
    const users = Object.entries(this.watchers);
    const factions = Object.entries(this.factions.items);
    
    return {
      users: {
        total: users.length,
        active: users.filter(([, c]) => c?.enabled !== false).length,
      },
      factions: {
        total: factions.length,
        active: factions.filter(([, f]) => f?.enabled !== false).length,
        members: factions.reduce(
          (sum, [, f]) => sum + Object.keys(f?.members || {}).length,
          0
        ),
      },
      alerts: {
        bars: BARS.filter(b => this.self.bars[b]).length,
        cooldowns: COOLDOWNS.filter(c => this.self.cooldowns[c]).length,
        chain: this.self.chain.enabled,
      },
    };
  }
}

// Singleton instance
const store = new Store(path.resolve(config.persist));

module.exports = store;

================================================================================

File: src/utils/format.js
----------------------------------------


const { STATES, EMOJI } = require('../config/constants');

/**
 * Capitalize first letter
 */
function capitalize(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

/**
 * Create visual progress bar
 */
function progressBar(current, max, length = 10, options = {}) {
  const { 
    filledChar = 'â–ˆ', 
    emptyChar = 'â–‘',
    showValues = true,
    showPercent = false,
  } = options;
  
  const pct = Math.max(0, Math.min(1, current / max));
  const filled = Math.round(pct * length);
  const bar = filledChar.repeat(filled) + emptyChar.repeat(length - filled);
  
  if (showPercent) {
    return `${bar} ${Math.round(pct * 100)}%`;
  }
  
  if (showValues) {
    return `${bar} ${current.toLocaleString()}/${max.toLocaleString()}`;
  }
  
  return bar;
}

/**
 * Parse states from user input with fuzzy matching
 */
function parseStates(input) {
  if (!input?.trim()) return [...STATES];
  
  const val = input.trim().toLowerCase();
  
  // Special values
  if (['all', '*', 'any'].includes(val)) return [...STATES];
  if (['none', '-', 'off', 'false', '0'].includes(val)) return [];
  
  const parsed = [];
  const parts = input.split(/[,\s|]+/);
  
  for (const part of parts) {
    const low = part.toLowerCase().trim();
    if (!low) continue;
    
    const match = STATES.find(s => s.toLowerCase().startsWith(low));
    if (!match) {
      throw new Error(`Unknown state: "${part}". Valid: ${STATES.join(', ')}`);
    }
    
    if (!parsed.includes(match)) {
      parsed.push(match);
    }
  }
  
  return parsed;
}

/**
 * Format states for display
 */
function formatStates(states, options = {}) {
  const { useEmoji = true, separator = ' ' } = options;
  
  if (!states?.length) return '*none*';
  
  if (useEmoji) {
    return states.map(s => EMOJI[s] || s).join(separator);
  }
  
  return states.join(', ');
}

/**
 * Clamp number between min and max
 */
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

/**
 * Format number with locale separators
 */
function formatNumber(num) {
  return Number(num || 0).toLocaleString();
}

/**
 * Truncate string to length
 */
function truncate(str, length, suffix = '...') {
  if (!str || str.length <= length) return str;
  return str.slice(0, length - suffix.length) + suffix;
}

/**
 * Sleep for specified milliseconds
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Create unique session key for pre-alerts
 */
function sessionKey(state, status, travel) {
  if (state === 'Traveling' && travel?.startedAt) {
    return `T:${travel.direction}:${travel.startedAt}`;
  }
  if (['Jail', 'Hospital'].includes(state) && status?.until) {
    return `${state[0]}:${status.until}`;
  }
  return null;
}

module.exports = {
  capitalize,
  progressBar,
  parseStates,
  formatStates,
  clamp,
  formatNumber,
  truncate,
  sleep,
  sessionKey,
  // Alias
  cap: capitalize,
};

================================================================================

File: src/utils/index.js
----------------------------------------
// Re-export all utilities
module.exports = {
    ...require('./time'),
    ...require('./travel'),
    ...require('./format'),
  };

================================================================================

File: src/utils/time.js
----------------------------------------
/**
 * Parse human-readable time string to seconds
 * Supports: "5m", "1h30m", "90s", "2h", plain numbers
 * @param {string|number} input - Time string or seconds
 * @returns {number|null} Seconds or null if invalid
 */
function parseTime(input) {
  if (input == null) return null;
  
  const str = String(input).toLowerCase().trim();
  if (!str) return null;
  
  // Plain number = seconds
  if (/^\d+$/.test(str)) {
    return parseInt(str, 10);
  }
  
  let total = 0;
  const patterns = [
    { regex: /(\d+(?:\.\d+)?)\s*h/i, multiplier: 3600 },
    { regex: /(\d+(?:\.\d+)?)\s*m(?:in)?/i, multiplier: 60 },
    { regex: /(\d+(?:\.\d+)?)\s*s(?:ec)?/i, multiplier: 1 },
  ];
  
  for (const { regex, multiplier } of patterns) {
    const match = str.match(regex);
    if (match) {
      total += parseFloat(match[1]) * multiplier;
    }
  }
  
  return total > 0 ? Math.floor(total) : null;
}

/**
 * Format seconds to human-readable string
 * @param {number} seconds - Duration in seconds
 * @param {object} options - Formatting options
 * @returns {string} Formatted time string
 */
function formatTime(seconds, options = {}) {
  const { 
    verbose = false, 
    showSeconds = true,
    maxParts = 3 
  } = options;
  
  if (!seconds || seconds <= 0) return 'now';
  
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  const s = Math.floor(seconds % 60);
  
  const parts = [];
  
  if (h > 0) {
    parts.push(verbose ? `${h} hour${h !== 1 ? 's' : ''}` : `${h}h`);
  }
  if (m > 0) {
    parts.push(verbose ? `${m} minute${m !== 1 ? 's' : ''}` : `${m}m`);
  }
  if (s > 0 && showSeconds && (parts.length < maxParts || !h)) {
    parts.push(verbose ? `${s} second${s !== 1 ? 's' : ''}` : `${s}s`);
  }
  
  if (parts.length === 0) return 'now';
  
  return verbose ? parts.join(', ') : parts.join(' ');
}

/**
 * Parse multiple time values from comma-separated string
 * @param {string} input - Comma-separated times
 * @returns {number[]} Array of seconds, sorted descending
 */
function parseTimes(input) {
  if (!input) return [];
  
  const str = input.toLowerCase().trim();
  if (['off', 'none', '-', 'disable', '0', 'false'].includes(str)) {
    return [];
  }
  
  const times = input
    .split(/[,\s]+/)
    .map(parseTime)
    .filter(t => t != null && t > 0);
  
  // Remove duplicates and sort descending
  return [...new Set(times)].sort((a, b) => b - a);
}

/**
 * Create Discord timestamp
 * @param {number} unix - Unix timestamp in seconds
 * @param {string} style - Discord timestamp style
 * @returns {string} Discord timestamp string
 */
function discordTimestamp(unix, style = 'f') {
  return `<t:${Math.floor(unix)}:${style}>`;
}

/**
 * Get relative time description
 * @param {number} timestamp - Unix timestamp in seconds
 * @returns {string} Relative time string
 */
function relativeTime(timestamp) {
  const now = Math.floor(Date.now() / 1000);
  const diff = timestamp - now;
  
  if (Math.abs(diff) < 60) return 'just now';
  
  const absDiff = Math.abs(diff);
  const future = diff > 0;
  
  if (absDiff < 3600) {
    const mins = Math.floor(absDiff / 60);
    return future ? `in ${mins}m` : `${mins}m ago`;
  }
  
  if (absDiff < 86400) {
    const hours = Math.floor(absDiff / 3600);
    return future ? `in ${hours}h` : `${hours}h ago`;
  }
  
  const days = Math.floor(absDiff / 86400);
  return future ? `in ${days}d` : `${days}d ago`;
}

module.exports = {
  parseTime,
  formatTime,
  parseTimes,
  discordTimestamp,
  relativeTime,
  // Aliases
  humanTime: formatTime,
  ts: discordTimestamp,
};

================================================================================

File: src/utils/travel.js
----------------------------------------
const { DESTINATIONS, TRAVEL_TIMES } = require('../config/constants');

const TRAVEL_PAD = 0.03; // 3% padding for estimation

/**
 * Get travel time for a destination and travel type
 */
function getTravelTime(type, destination) {
  const idx = DESTINATIONS.findIndex(
    d => d.toLowerCase() === destination?.toLowerCase()
  );
  return idx >= 0 ? TRAVEL_TIMES[type]?.[idx] : null;
}

/**
 * Estimate arrival window for travel
 */
function estimateTravel(type, destination, startMs) {
  const startSec = Math.floor(startMs / 1000);
  
  if (!destination) {
    return { earliest: null, latest: null };
  }
  
  // Standard class could be economy or business
  if (type === 'standard') {
    const econ = getTravelTime('standard_economy', destination);
    const bus = getTravelTime('standard_business', destination);
    
    if (!econ || !bus) return { earliest: null, latest: null };
    
    return {
      earliest: Math.floor(startSec + Math.min(econ, bus) * (1 - TRAVEL_PAD)),
      latest: Math.floor(startSec + Math.max(econ, bus) * (1 + TRAVEL_PAD)),
    };
  }
  
  const sec = getTravelTime(type, destination);
  if (!sec) return { earliest: null, latest: null };
  
  return {
    earliest: Math.floor(startSec + sec * (1 - TRAVEL_PAD)),
    latest: Math.floor(startSec + sec * (1 + TRAVEL_PAD)),
  };
}

/**
 * Parse destination from status description
 */
function parseDestination(description) {
  if (!description) return null;
  
  // Match "Traveling to X" or "Returning from X"
  const match = description.match(/(?:from|to)\s+([A-Za-z\s-]+)$/i);
  if (!match) return null;
  
  const dest = match[1].replace(/[^\w\s-]/g, '').trim();
  
  // Try to find exact match in known destinations
  const known = DESTINATIONS.find(
    d => d.toLowerCase() === dest.toLowerCase()
  );
  
  return known || dest;
}

/**
 * Parse travel direction from status description
 */
function parseTravelDirection(description) {
  if (!description) return 'outbound';
  return /returning|from\s+\w/i.test(description) ? 'return' : 'outbound';
}

/**
 * Infer travel type from status
 */
function inferTravelType(status) {
  return status?.travel_type?.toLowerCase() || 'standard';
}

/**
 * Create complete travel info from status
 */
function createTravelInfo(status) {
  const description = status?.description || '';
  const destination = parseDestination(description);
  const type = inferTravelType(status);
  const direction = parseTravelDirection(description);
  const startedAt = Date.now();
  
  return {
    startedAt,
    type,
    destination,
    direction,
    ...estimateTravel(type, destination, startedAt),
  };
}

/**
 * Format destination for display
 */
function formatDestination(travel) {
  if (!travel?.destination) return 'Unknown';
  
  return travel.direction === 'return'
    ? `â† Returning from ${travel.destination}`
    : `â†’ Flying to ${travel.destination}`;
}

/**
 * Get ETA timestamp (midpoint of estimation window)
 */
function getETA(travel) {
  if (!travel?.earliest || !travel?.latest) return null;
  return Math.floor((travel.earliest + travel.latest) / 2);
}

module.exports = {
  getTravelTime,
  estimateTravel,
  parseDestination,
  parseTravelDirection,
  inferTravelType,
  createTravelInfo,
  formatDestination,
  getETA,
  DESTINATIONS,
};


================================================================================

File: index.js
----------------------------------------
require('dotenv').config();

const fs = require('fs');
const path = require('path');
const axios = require('axios');
const express = require('express');
const {
  Client, GatewayIntentBits, Partials, SlashCommandBuilder,
  ActionRowBuilder, StringSelectMenuBuilder, ButtonBuilder, ButtonStyle,
  EmbedBuilder, ModalBuilder, TextInputBuilder, TextInputStyle
} = require('discord.js');

// ========= Configuration =========
const CONFIG = {
  discord: { token: process.env.DISCORD_TOKEN, ownerId: process.env.OWNER_DISCORD_ID, guildId: process.env.GUILD_ID },
  torn: { apiKey: process.env.TORN_API_KEY, userIds: process.env.USER_IDS, factionIds: process.env.FACTION_IDS },
  timing: { requestMs: Number(process.env.REQUEST_INTERVAL_MS) || 5000, factionMs: Number(process.env.FACTION_INTERVAL_MS) || 30000 },
  persist: process.env.PERSIST_PATH || './store.json',
  port: Number(process.env.PORT) || 3000,
  defaults: { offlineHours: Number(process.env.FACTION_OFFLINE_HOURS) || 24 }
};

['token', 'ownerId'].forEach(k => { if (!CONFIG.discord[k]) throw new Error(`Missing DISCORD_${k.toUpperCase()}`); });
if (!CONFIG.torn.apiKey) throw new Error('Missing TORN_API_KEY');

// ========= Constants =========
const STATES = ['Traveling', 'Abroad', 'Jail', 'Hospital', 'Okay'];
const BARS = ['energy', 'nerve', 'happy', 'life'];
const COOLDOWNS = ['drug', 'medical', 'booster'];

const EMOJI = {
  Traveling: 'âœˆï¸', Abroad: 'ğŸ—ºï¸', Jail: 'ğŸš”', Hospital: 'ğŸ¥', Okay: 'âœ…',
  energy: 'âš¡', nerve: 'ğŸ’¢', happy: 'ğŸ˜Š', life: 'â¤ï¸',
  drug: 'ğŸ’Š', medical: 'ğŸ©¹', booster: 'ğŸ’‰',
  chain: 'â›“ï¸', on: 'ğŸŸ¢', off: 'ğŸ”´', user: 'ğŸ‘¤', faction: 'ğŸ´'
};

const COLORS = {
  Traveling: 0x2b8aeb, Abroad: 0xffc107, Jail: 0x6c757d, Hospital: 0xdc3545, Okay: 0x28a745,
  brand: 0x5865F2, warn: 0xff9800, good: 0x1abc9c, bad: 0xe53935
};

const DESTINATIONS = ['Mexico', 'Cayman Islands', 'Canada', 'Hawaii', 'United Kingdom', 'Argentina', 'Switzerland', 'Japan', 'China', 'UAE', 'South Africa'];
const TRAVEL_TIMES = {
  standard_economy: [1560, 2100, 2460, 8040, 9540, 10020, 10500, 13500, 14520, 16260, 17820],
  standard_business: [480, 660, 720, 2400, 2880, 3000, 3180, 4080, 4320, 4860, 5340],
  airstrip: [1080, 1500, 1740, 5640, 6660, 7020, 7380, 9480, 10140, 11400, 12480],
  private: [780, 1080, 1200, 4020, 4800, 4980, 5280, 6780, 7260, 8100, 8940]
};

// ========= Utilities =========
const cap = s => s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
const profileUrl = id => `https://www.torn.com/profiles.php?XID=${id}`;
const ts = (unix, style = 'f') => `<t:${unix}:${style}>`;
const sleep = ms => new Promise(r => setTimeout(r, ms));
const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

// Parse human time: "5m", "1h30m", "90s", "2h" -> seconds
const parseTime = input => {
  if (!input) return null;
  const str = input.toString().toLowerCase().trim();
  if (/^\d+$/.test(str)) return parseInt(str); // plain seconds
  let total = 0;
  const h = str.match(/(\d+)\s*h/), m = str.match(/(\d+)\s*m/), s = str.match(/(\d+)\s*s/);
  if (h) total += parseInt(h[1]) * 3600;
  if (m) total += parseInt(m[1]) * 60;
  if (s) total += parseInt(s[1]);
  return total || null;
};

// Format seconds to human: 3661 -> "1h 1m 1s"
const humanTime = sec => {
  if (!sec || sec <= 0) return 'now';
  const h = Math.floor(sec / 3600), m = Math.floor((sec % 3600) / 60), s = sec % 60;
  const parts = [];
  if (h) parts.push(`${h}h`);
  if (m) parts.push(`${m}m`);
  if (s && !h) parts.push(`${s}s`);
  return parts.join(' ') || 'now';
};

// Parse multiple times: "5m, 2m, 30s" -> [300, 120, 30]
const parseTimes = input => {
  if (!input) return [];
  const low = input.toLowerCase().trim();
  if (['off', 'none', '-', 'disable', '0'].includes(low)) return [];
  return [...new Set(input.split(/[,\s]+/).map(parseTime).filter(n => n > 0))].sort((a, b) => b - a);
};

// Parse states with fuzzy matching
const parseStates = input => {
  if (!input?.trim()) return [...STATES];
  const val = input.trim().toLowerCase();
  if (['all', '*', 'any'].includes(val)) return [...STATES];
  if (['none', '-', 'off'].includes(val)) return [];
  return [...new Set(input.split(/[,\s|]+/).map(s => {
    const low = s.toLowerCase();
    const match = STATES.find(st => st.toLowerCase().startsWith(low));
    if (!match) throw new Error(`Unknown state: "${s}". Try: ${STATES.join(', ')}`);
    return match;
  }))];
};

// Progress bar visualization
const progressBar = (current, max, length = 10) => {
  const pct = clamp(current / max, 0, 1);
  const filled = Math.round(pct * length);
  return 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(length - filled) + ` ${current}/${max}`;
};

// Travel estimation
const getTravelTime = (type, dest) => {
  const idx = DESTINATIONS.findIndex(d => d.toLowerCase() === dest?.toLowerCase());
  return idx >= 0 ? TRAVEL_TIMES[type]?.[idx] : null;
};

const estimateTravel = (type, dest, startMs) => {
  const PAD = 0.03, startSec = Math.floor(startMs / 1000);
  if (!dest) return { earliest: null, latest: null };
  if (type === 'standard') {
    const [econ, bus] = ['standard_economy', 'standard_business'].map(t => getTravelTime(t, dest));
    if (!econ || !bus) return { earliest: null, latest: null };
    return { earliest: Math.floor(startSec + Math.min(econ, bus) * (1 - PAD)), latest: Math.floor(startSec + Math.max(econ, bus) * (1 + PAD)) };
  }
  const sec = getTravelTime(type, dest);
  return sec ? { earliest: Math.floor(startSec + sec * (1 - PAD)), latest: Math.floor(startSec + sec * (1 + PAD)) } : { earliest: null, latest: null };
};

const parseDestination = desc => {
  const match = desc?.match(/(?:from|to)\s+([A-Za-z\s-]+)$/i);
  const dest = match?.[1]?.replace(/[^\w\s-]/g, '').trim();
  return DESTINATIONS.find(d => d.toLowerCase() === dest?.toLowerCase()) || dest;
};

const parseTravelDir = desc => /returning|from\s+\w/i.test(desc || '') ? 'return' : 'outbound';
const inferTravelType = status => status?.travel_type?.toLowerCase() || 'standard';

const createTravel = status => {
  const desc = status?.description || '';
  const dest = parseDestination(desc), type = inferTravelType(status), dir = parseTravelDir(desc);
  return { startedAt: Date.now(), type, dest, direction: dir, ...estimateTravel(type, dest, Date.now()) };
};

// ========= Storage =========
class Store {
  constructor(configPath) {
    this.path = this._resolvePath(configPath);
    this.data = { requestMs: CONFIG.timing.requestMs, watchers: {}, self: this._selfDefaults(), factions: { requestMs: CONFIG.timing.factionMs, items: {} } };
    this.timer = null;
  }

  _resolvePath(target) {
    try { fs.mkdirSync(path.dirname(target), { recursive: true }); fs.writeFileSync(target + '.probe', ''); fs.unlinkSync(target + '.probe'); return target; }
    catch { return '/tmp/store.json'; }
  }

  _selfDefaults() {
    return {
      bars: { energy: false, nerve: false, happy: false, life: false, last: {}, wasFull: {} },
      cooldowns: { drug: false, medical: false, booster: false, last: {} },
      chain: { enabled: false, min: 10, thresholds: [120, 60, 30], last: {}, epochId: 0, fired: {} }
    };
  }

  load() {
    try {
      if (fs.existsSync(this.path)) {
        const raw = fs.readFileSync(this.path, 'utf8').trim();
        if (raw) Object.assign(this.data, JSON.parse(raw));
      }
      this.data.watchers ??= {};
      this.data.self ??= this._selfDefaults();
      this.data.factions ??= { requestMs: CONFIG.timing.factionMs, items: {} };
    } catch (e) { console.warn('[store] Load failed:', e.message); }
  }

  save(reason = '') {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      try { const tmp = this.path + '.tmp'; fs.writeFileSync(tmp, JSON.stringify(this.data, null, 2)); fs.renameSync(tmp, this.path); }
      catch (e) { console.warn('[store] Save failed:', e.message); }
    }, 300);
  }

  get watchers() { return this.data.watchers; }
  get self() { return this.data.self; }
  get factions() { return this.data.factions; }
  get requestMs() { return this.data.requestMs; }
  set requestMs(v) { this.data.requestMs = v; }
}

const store = new Store(path.resolve(CONFIG.persist));

// ========= API =========
class TornAPI {
  constructor(key) {
    this.key = key;
    this.v2 = axios.create({ baseURL: 'https://api.torn.com/v2', timeout: 12000 });
    this.v1 = axios.create({ baseURL: 'https://api.torn.com', timeout: 12000 });
  }
  async getProfile(id) { const { data } = await this.v2.get(`/user/${id}/basic`, { params: { striptags: true, key: this.key } }); return data?.profile; }
  async getBars() { const { data } = await this.v1.get('/user/', { params: { key: this.key, selections: 'bars' } }); return data; }
  async getCooldowns() { const { data } = await this.v1.get('/user/', { params: { key: this.key, selections: 'cooldowns' } }); return data?.cooldowns; }
  async getFaction(id) { const { data } = await this.v1.get(`/faction/${id}`, { params: { key: this.key, selections: 'basic' } }); return data; }
  async searchUser(name) { const { data } = await this.v1.get('/user/', { params: { key: this.key, selections: 'search', name } }); return data; }
}

const api = new TornAPI(CONFIG.torn.apiKey);

// ========= Notification System =========
let client;

const notify = async (embeds, components = []) => {
  try {
    const user = await client.users.fetch(CONFIG.discord.ownerId, { force: true });
    await user.send({ embeds: Array.isArray(embeds) ? embeds : [embeds], components });
  } catch (e) { console.error('[dm] Failed:', e.message); }
};

// ========= Smart Embeds =========
const Embeds = {
  // Main dashboard showing everything
  dashboard() {
    const { watchers, self, factions } = store.data;
    const userCount = Object.keys(watchers).filter(id => watchers[id]?.enabled !== false).length;
    const factionCount = Object.keys(factions.items).filter(id => factions.items[id]?.enabled !== false).length;
    
    const barStatus = BARS.map(b => `${EMOJI[b]} ${cap(b)}: ${self.bars[b] ? EMOJI.on : EMOJI.off}`).join('\n');
    const cdStatus = COOLDOWNS.map(c => `${EMOJI[c]} ${cap(c)}: ${self.cooldowns[c] ? EMOJI.on : EMOJI.off}`).join('\n');
    const chainStatus = `${EMOJI.chain} Chain: ${self.chain.enabled ? `${EMOJI.on} (min ${self.chain.min}, alerts at ${self.chain.thresholds.map(t => humanTime(t)).join(', ')})` : EMOJI.off}`;

    return new EmbedBuilder()
      .setColor(COLORS.brand)
      .setTitle('ğŸ“Š Torn Tracker Dashboard')
      .setDescription('Your active tracking configuration')
      .addFields(
        { name: `${EMOJI.user} Users Tracked`, value: userCount ? `${userCount} active` : 'None', inline: true },
        { name: `${EMOJI.faction} Factions Tracked`, value: factionCount ? `${factionCount} active` : 'None', inline: true },
        { name: '\u200b', value: '\u200b', inline: true },
        { name: 'âš¡ Bar Alerts', value: barStatus, inline: true },
        { name: 'ğŸ’Š Cooldown Alerts', value: cdStatus, inline: true },
        { name: '\u200b', value: chainStatus, inline: false }
      )
      .setFooter({ text: 'Use buttons below to configure â€¢ /help for commands' })
      .setTimestamp();
  },

  // User list
  userList() {
    const entries = Object.entries(store.watchers);
    if (!entries.length) {
      return new EmbedBuilder().setColor(COLORS.brand).setTitle(`${EMOJI.user} Tracked Users`).setDescription('No users tracked yet.\n\nUse `/track` to add someone!');
    }
    
    const lines = entries.map(([id, cfg]) => {
      const status = cfg.enabled === false ? EMOJI.off : EMOJI.on;
      const stateEmoji = cfg.lastState ? EMOJI[cfg.lastState] || 'â“' : 'â“';
      const states = cfg.states?.length ? cfg.states.map(s => EMOJI[s]).join('') : 'none';
      const pre = cfg.preTimesSec?.length ? ` â€¢ â° ${cfg.preTimesSec.map(humanTime).join(', ')}` : '';
      return `${status} **${cfg.name || id}** ${stateEmoji} ${cfg.lastState || 'Unknown'}\nâ”— Alerts: ${states}${pre}`;
    });

    return new EmbedBuilder()
      .setColor(COLORS.brand)
      .setTitle(`${EMOJI.user} Tracked Users (${entries.length})`)
      .setDescription(lines.join('\n\n'))
      .setFooter({ text: 'Select a user below to configure' });
  },

  // Faction list
  factionList() {
    const items = store.factions.items;
    const entries = Object.entries(items);
    if (!entries.length) {
      return new EmbedBuilder().setColor(COLORS.brand).setTitle(`${EMOJI.faction} Tracked Factions`).setDescription('No factions tracked yet.\n\nUse `/track` to add one!');
    }
    
    const lines = entries.map(([id, f]) => {
      const status = f.enabled === false ? EMOJI.off : EMOJI.on;
      const memberCount = Object.keys(f.members || {}).length;
      const states = f.states?.length ? f.states.map(s => EMOJI[s]).join('') : 'none';
      const features = [
        f.offline?.enabled !== false ? `offline>${f.offline?.hours || 24}h` : null,
        f.daily?.enabled !== false ? 'daily' : null
      ].filter(Boolean).join(', ');
      return `${status} **${f.name || `Faction ${id}`}**\nâ”— ${memberCount} members â€¢ Alerts: ${states}${features ? ` â€¢ ${features}` : ''}`;
    });

    return new EmbedBuilder()
      .setColor(COLORS.brand)
      .setTitle(`${EMOJI.faction} Tracked Factions (${entries.length})`)
      .setDescription(lines.join('\n\n'))
      .setFooter({ text: 'Select a faction below to configure' });
  },

  // Personal alerts config
  alertsConfig() {
    const { self } = store.data;
    
    const barLines = BARS.map(b => {
      const on = self.bars[b];
      const last = self.bars.last[b];
      const bar = last ? progressBar(last.current || 0, last.maximum || 100, 8) : 'No data';
      return `${EMOJI[b]} **${cap(b)}**: ${on ? EMOJI.on : EMOJI.off}\nâ”— ${bar}`;
    });

    const cdLines = COOLDOWNS.map(c => {
      const on = self.cooldowns[c];
      const last = self.cooldowns.last[c];
      const time = last > 0 ? humanTime(last) : 'Ready';
      return `${EMOJI[c]} **${cap(c)}**: ${on ? EMOJI.on : EMOJI.off} (${time})`;
    });

    const chain = self.chain;
    const chainLine = `${EMOJI.chain} **Chain**: ${chain.enabled ? EMOJI.on : EMOJI.off}\nâ”— Min: ${chain.min} â€¢ Alerts: ${chain.thresholds.map(humanTime).join(', ')}`;

    return new EmbedBuilder()
      .setColor(COLORS.brand)
      .setTitle('ğŸ”” Personal Alerts')
      .setDescription('Configure alerts for your own account')
      .addFields(
        { name: 'âš¡ Bars (alert when full)', value: barLines.join('\n'), inline: false },
        { name: 'ğŸ’Š Cooldowns (alert when ready)', value: cdLines.join('\n'), inline: false },
        { name: 'â›“ï¸ Chain Timer', value: chainLine, inline: false }
      )
      .setFooter({ text: 'Click buttons to toggle â€¢ Last updated' })
      .setTimestamp();
  },

  // User status card
  userStatus(userId, profile, cfg) {
    const status = profile?.status || {};
    const state = status.state || 'Okay';
    const travel = cfg?.travel;

    const emb = new EmbedBuilder()
      .setColor(COLORS[state] || COLORS.brand)
      .setAuthor({ name: `${profile?.name || cfg?.name || 'User'} [${userId}]`, url: profileUrl(userId) })
      .setTitle(`${EMOJI[state] || 'â“'} ${state}`)
      .setTimestamp();

    const lines = [];
    if (status.description) lines.push(status.description);

    if (state === 'Traveling' && travel?.earliest) {
      const mid = Math.floor((travel.earliest + travel.latest) / 2);
      const dest = travel.direction === 'return' ? `Torn â† ${travel.dest}` : `â†’ ${travel.dest}`;
      lines.push(`**Destination:** ${dest}`, `**ETA:** ${ts(mid, 'R')} (${ts(mid, 't')})`);
    } else if (['Jail', 'Hospital'].includes(state) && status.until) {
      lines.push(`**Ends:** ${ts(Number(status.until), 'R')} (${ts(Number(status.until), 't')})`);
    }

    emb.setDescription(lines.join('\n') || 'No additional info');

    if (cfg) {
      const alerts = cfg.states?.length ? cfg.states.map(s => `${EMOJI[s]} ${s}`).join(', ') : 'None';
      const pre = cfg.preTimesSec?.length ? cfg.preTimesSec.map(humanTime).join(', ') : 'None';
      emb.addFields(
        { name: 'Alert States', value: alerts, inline: true },
        { name: 'Early Warnings', value: pre, inline: true },
        { name: 'Status', value: cfg.enabled === false ? `${EMOJI.off} Paused` : `${EMOJI.on} Active`, inline: true }
      );
    }

    return emb;
  },

  // Notification embeds
  stateChange(userId, name, oldState, newState, status, travel) {
    const lines = [];
    if (status?.description) lines.push(status.description);

    if (newState === 'Traveling' && travel?.earliest) {
      const mid = Math.floor((travel.earliest + travel.latest) / 2);
      const dest = travel.direction === 'return' ? `Torn â† ${travel.dest}` : `â†’ ${travel.dest}`;
      lines.push(`**Destination:** ${dest}`, `**ETA:** ${ts(mid, 'R')}`);
    } else if (['Jail', 'Hospital'].includes(newState) && status?.until) {
      lines.push(`**Ends:** ${ts(Number(status.until), 'R')}`);
    }

    return new EmbedBuilder()
      .setColor(COLORS[newState] || COLORS.brand)
      .setTitle(`${EMOJI[newState]} ${name} â†’ ${newState}`)
      .setDescription(lines.join('\n') || null)
      .addFields({ name: 'Previous', value: `${EMOJI[oldState] || 'â“'} ${oldState || 'Unknown'}`, inline: true })
      .setURL(profileUrl(userId))
      .setTimestamp();
  },

  preAlert(name, userId, state, endAt, left) {
    return new EmbedBuilder()
      .setColor(COLORS.warn)
      .setTitle(`â° ${name} - ${state} ending soon!`)
      .setDescription(`**Ends:** ${ts(endAt, 'R')} (${ts(endAt, 't')})\n**Time left:** ~${humanTime(left)}`)
      .setURL(profileUrl(userId))
      .setTimestamp();
  },

  barFull(kind, bar) {
    return new EmbedBuilder()
      .setColor(COLORS.good)
      .setTitle(`${EMOJI[kind]} ${cap(kind)} is FULL!`)
      .setDescription(progressBar(bar.current, bar.maximum, 15))
      .setTimestamp();
  },

  cooldownReady(kind) {
    return new EmbedBuilder().setColor(COLORS.good).setTitle(`${EMOJI[kind]} ${cap(kind)} cooldown ready!`).setTimestamp();
  },

  chainAlert(chain, threshold) {
    const pct = Math.round((chain.timeout / 300) * 100);
    return new EmbedBuilder()
      .setColor(chain.timeout <= 30 ? COLORS.bad : COLORS.warn)
      .setTitle(`${EMOJI.chain} Chain Alert!`)
      .setDescription(`**Chain:** ${chain.current}/${chain.maximum}\n**Time left:** ${humanTime(chain.timeout)}\n${progressBar(chain.timeout, 300, 15)}`)
      .setTimestamp();
  },

  factionMemberChange(fName, uid, member, oldState, newState, travel) {
    const lines = [];
    if (newState === 'Traveling' && travel?.earliest) {
      const mid = Math.floor((travel.earliest + travel.latest) / 2);
      lines.push(`**ETA:** ${ts(mid, 'R')}`);
    } else if (['Jail', 'Hospital'].includes(newState) && member?.status?.until) {
      lines.push(`**Ends:** ${ts(Number(member.status.until), 'R')}`);
    }

    return new EmbedBuilder()
      .setColor(COLORS[newState] || COLORS.brand)
      .setTitle(`${EMOJI[newState]} ${member.name} â†’ ${newState}`)
      .setDescription(`**Faction:** ${fName}${lines.length ? '\n' + lines.join('\n') : ''}`)
      .addFields({ name: 'Previous', value: `${EMOJI[oldState] || 'â“'} ${oldState || '?'}`, inline: true })
      .setURL(profileUrl(uid))
      .setTimestamp();
  },

  factionJoinLeave(type, fName, uid, name) {
    const join = type === 'join';
    return new EmbedBuilder()
      .setColor(join ? COLORS.good : COLORS.bad)
      .setTitle(`${join ? 'ğŸŸ¢' : 'ğŸ”´'} ${name} ${join ? 'joined' : 'left'} ${fName}`)
      .setURL(profileUrl(uid))
      .setTimestamp();
  },

  factionOffline(fName, uid, name, lastTs, hours) {
    return new EmbedBuilder()
      .setColor(COLORS.warn)
      .setTitle(`ğŸ˜´ ${name} offline > ${hours}h`)
      .setDescription(`**Faction:** ${fName}\n**Last seen:** ${ts(Number(lastTs), 'R')}`)
      .setURL(profileUrl(uid))
      .setTimestamp();
  },

  factionDaily(fName, delta, total) {
    const up = delta >= 0;
    return new EmbedBuilder()
      .setColor(up ? COLORS.good : COLORS.bad)
      .setTitle(`ğŸ“ˆ ${fName} Daily Report`)
      .setDescription(`${up ? 'ğŸ“ˆ' : 'ğŸ“‰'} **${up ? '+' : ''}${delta.toLocaleString()}** respect\n**Total:** ${total.toLocaleString()}`)
      .setTimestamp();
  },

  factionMilestone(fName, respect) {
    const milestone = Math.floor(respect / 100000) * 100000;
    return new EmbedBuilder()
      .setColor(COLORS.good)
      .setTitle(`ğŸ‰ ${fName} hit ${milestone.toLocaleString()} respect!`)
      .setTimestamp();
  },

  help() {
    return new EmbedBuilder()
      .setColor(COLORS.brand)
      .setTitle('ğŸ“– Torn Tracker Help')
      .setDescription('Quick reference for all commands')
      .addFields(
        { name: 'ğŸ“Š /dashboard', value: 'Main control panel - see everything at a glance', inline: false },
        { name: 'ğŸ‘¤ /track user <id>', value: 'Add a user to track\nâ€¢ Optional: `alerts` (states like "jail,hospital")\nâ€¢ Optional: `warn` (early warnings like "5m,2m")', inline: false },
        { name: 'ğŸ´ /track faction <id>', value: 'Add a faction to track\nâ€¢ Optional: `alerts`, `warn`, `offline` hours', inline: false },
        { name: 'ğŸ”” /alerts', value: 'Configure personal bar/cooldown/chain alerts', inline: false },
        { name: 'ğŸ‘ï¸ /status <id>', value: 'Quick status check for any user', inline: false },
        { name: 'â±ï¸ /delay <id> <time>', value: 'Add delay to travel ETA (e.g., "5m")', inline: false },
        { name: 'ğŸ—‘ï¸ /remove <id>', value: 'Stop tracking a user or faction', inline: false }
      )
      .addFields({ name: 'ğŸ’¡ Time Format', value: 'Use human-readable times: `5m`, `1h30m`, `90s`', inline: false })
      .setFooter({ text: 'Tip: Most configuration can be done through button menus!' });
  }
};

// ========= UI Components =========
const Components = {
  dashboardButtons() {
    return [
      new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('dash:users').setLabel('Users').setEmoji('ğŸ‘¤').setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId('dash:factions').setLabel('Factions').setEmoji('ğŸ´').setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId('dash:alerts').setLabel('Personal Alerts').setEmoji('ğŸ””').setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId('dash:refresh').setLabel('Refresh').setEmoji('ğŸ”„').setStyle(ButtonStyle.Secondary)
      )
    ];
  },

  userListMenu() {
    const entries = Object.entries(store.watchers).slice(0, 25);
    if (!entries.length) return [];
    
    return [
      new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('select:user')
          .setPlaceholder('Select a user to configure...')
          .addOptions(entries.map(([id, cfg]) => ({
            label: cfg.name || `User ${id}`,
            description: `${cfg.enabled === false ? 'Paused' : 'Active'} â€¢ ${cfg.lastState || 'Unknown'}`,
            value: id,
            emoji: cfg.enabled === false ? EMOJI.off : EMOJI.on
          })))
      ),
      new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('dash:main').setLabel('Back').setEmoji('â—€ï¸').setStyle(ButtonStyle.Secondary),
        new ButtonBuilder().setCustomId('modal:adduser').setLabel('Add User').setEmoji('â•').setStyle(ButtonStyle.Success)
      )
    ];
  },

  factionListMenu() {
    const entries = Object.entries(store.factions.items).slice(0, 25);
    if (!entries.length) {
      return [
        new ActionRowBuilder().addComponents(
          new ButtonBuilder().setCustomId('dash:main').setLabel('Back').setEmoji('â—€ï¸').setStyle(ButtonStyle.Secondary),
          new ButtonBuilder().setCustomId('modal:addfaction').setLabel('Add Faction').setEmoji('â•').setStyle(ButtonStyle.Success)
        )
      ];
    }
    
    return [
      new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('select:faction')
          .setPlaceholder('Select a faction to configure...')
          .addOptions(entries.map(([id, f]) => ({
            label: f.name || `Faction ${id}`,
            description: `${Object.keys(f.members || {}).length} members`,
            value: id,
            emoji: f.enabled === false ? EMOJI.off : EMOJI.on
          })))
      ),
      new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('dash:main').setLabel('Back').setEmoji('â—€ï¸').setStyle(ButtonStyle.Secondary),
        new ButtonBuilder().setCustomId('modal:addfaction').setLabel('Add Faction').setEmoji('â•').setStyle(ButtonStyle.Success)
      )
    ];
  },

  alertsButtons() {
    const { self } = store.data;
    
    const barRow = new ActionRowBuilder().addComponents(
      ...BARS.map(b => new ButtonBuilder()
        .setCustomId(`toggle:bar:${b}`)
        .setLabel(cap(b))
        .setEmoji(EMOJI[b])
        .setStyle(self.bars[b] ? ButtonStyle.Success : ButtonStyle.Secondary)
      )
    );

    const cdRow = new ActionRowBuilder().addComponents(
      ...COOLDOWNS.map(c => new ButtonBuilder()
        .setCustomId(`toggle:cd:${c}`)
        .setLabel(cap(c))
        .setEmoji(EMOJI[c])
        .setStyle(self.cooldowns[c] ? ButtonStyle.Success : ButtonStyle.Secondary)
      )
    );

    const chainRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('toggle:chain')
        .setLabel('Chain Alerts')
        .setEmoji(EMOJI.chain)
        .setStyle(self.chain.enabled ? ButtonStyle.Success : ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('modal:chain')
        .setLabel('Configure Chain')
        .setEmoji('âš™ï¸')
        .setStyle(ButtonStyle.Primary)
    );

    const navRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId('dash:main').setLabel('Back').setEmoji('â—€ï¸').setStyle(ButtonStyle.Secondary),
      new ButtonBuilder().setCustomId('alerts:refresh').setLabel('Refresh Status').setEmoji('ğŸ”„').setStyle(ButtonStyle.Primary)
    );

    return [barRow, cdRow, chainRow, navRow];
  },

  userConfig(userId) {
    const cfg = store.watchers[userId];
    if (!cfg) return [];

    const stateRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId(`states:${userId}`)
        .setPlaceholder('Select alert states...')
        .setMinValues(0)
        .setMaxValues(STATES.length)
        .addOptions(STATES.map(s => ({
          label: s,
          value: s,
          emoji: EMOJI[s],
          default: cfg.states?.includes(s)
        })))
    );

    const actionRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId(`toggle:user:${userId}`).setLabel(cfg.enabled === false ? 'Enable' : 'Pause').setStyle(cfg.enabled === false ? ButtonStyle.Success : ButtonStyle.Secondary),
      new ButtonBuilder().setCustomId(`modal:userwarn:${userId}`).setLabel('Early Warnings').setEmoji('â°').setStyle(ButtonStyle.Primary),
      new ButtonBuilder().setCustomId(`refresh:user:${userId}`).setLabel('Refresh').setEmoji('ğŸ”„').setStyle(ButtonStyle.Primary),
      new ButtonBuilder().setCustomId(`remove:user:${userId}`).setLabel('Remove').setStyle(ButtonStyle.Danger)
    );

    const navRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId('dash:users').setLabel('Back to List').setEmoji('â—€ï¸').setStyle(ButtonStyle.Secondary),
      new ButtonBuilder().setURL(profileUrl(userId)).setLabel('Open in Torn').setStyle(ButtonStyle.Link)
    );

    return [stateRow, actionRow, navRow];
  },

  factionConfig(fid) {
    const f = store.factions.items[fid];
    if (!f) return [];

    const stateRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId(`fstates:${fid}`)
        .setPlaceholder('Select alert states...')
        .setMinValues(0)
        .setMaxValues(STATES.length)
        .addOptions(STATES.map(s => ({
          label: s,
          value: s,
          emoji: EMOJI[s],
          default: f.states?.includes(s)
        })))
    );

    const featureRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId(`toggle:faction:${fid}`).setLabel(f.enabled === false ? 'Enable' : 'Pause').setStyle(f.enabled === false ? ButtonStyle.Success : ButtonStyle.Secondary),
      new ButtonBuilder().setCustomId(`toggle:foffline:${fid}`).setLabel(`Offline (${f.offline?.hours || 24}h)`).setEmoji('ğŸ˜´').setStyle(f.offline?.enabled !== false ? ButtonStyle.Success : ButtonStyle.Secondary),
      new ButtonBuilder().setCustomId(`toggle:fdaily:${fid}`).setLabel('Daily Report').setEmoji('ğŸ“ˆ').setStyle(f.daily?.enabled !== false ? ButtonStyle.Success : ButtonStyle.Secondary)
    );

    const actionRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId(`modal:factionwarn:${fid}`).setLabel('Early Warnings').setEmoji('â°').setStyle(ButtonStyle.Primary),
      new ButtonBuilder().setCustomId(`modal:factionoffline:${fid}`).setLabel('Offline Hours').setEmoji('âš™ï¸').setStyle(ButtonStyle.Primary),
      new ButtonBuilder().setCustomId(`remove:faction:${fid}`).setLabel('Remove').setStyle(ButtonStyle.Danger)
    );

    const navRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId('dash:factions').setLabel('Back to List').setEmoji('â—€ï¸').setStyle(ButtonStyle.Secondary)
    );

    return [stateRow, featureRow, actionRow, navRow];
  },

  quickActions(userId, state) {
    const actions = [new ButtonBuilder().setCustomId(`refresh:user:${userId}`).setLabel('Refresh').setEmoji('ğŸ”„').setStyle(ButtonStyle.Secondary)];
    
    if (state === 'Traveling') {
      actions.push(new ButtonBuilder().setCustomId(`modal:delay:${userId}`).setLabel('Add Delay').setEmoji('â±ï¸').setStyle(ButtonStyle.Primary));
    }
    
    actions.push(new ButtonBuilder().setURL(profileUrl(userId)).setLabel('Open in Torn').setStyle(ButtonStyle.Link));
    
    return [new ActionRowBuilder().addComponents(actions)];
  }
};

// ========= Modals =========
const Modals = {
  addUser() {
    return new ModalBuilder()
      .setCustomId('modal:adduser:submit')
      .setTitle('Add User to Track')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('user_id').setLabel('Torn User ID').setStyle(TextInputStyle.Short).setRequired(true).setPlaceholder('e.g., 12345')
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('states').setLabel('Alert States (optional)').setStyle(TextInputStyle.Short).setRequired(false).setPlaceholder('jail, hospital, traveling (or "all")')
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('warn').setLabel('Early Warnings (optional)').setStyle(TextInputStyle.Short).setRequired(false).setPlaceholder('e.g., 5m, 2m, 30s')
        )
      );
  },

  addFaction() {
    return new ModalBuilder()
      .setCustomId('modal:addfaction:submit')
      .setTitle('Add Faction to Track')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('faction_id').setLabel('Faction ID').setStyle(TextInputStyle.Short).setRequired(true).setPlaceholder('e.g., 12345')
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('states').setLabel('Alert States (optional)').setStyle(TextInputStyle.Short).setRequired(false).setPlaceholder('jail, hospital, traveling (or "all")')
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('offline').setLabel('Offline Alert Hours (optional)').setStyle(TextInputStyle.Short).setRequired(false).setPlaceholder('e.g., 24')
        )
      );
  },

  chainConfig() {
    const chain = store.self.chain;
    return new ModalBuilder()
      .setCustomId('modal:chain:submit')
      .setTitle('Chain Alert Settings')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('min').setLabel('Minimum Chain').setStyle(TextInputStyle.Short).setRequired(false).setPlaceholder('e.g., 10').setValue(String(chain.min || 10))
        ),
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('thresholds').setLabel('Alert Times').setStyle(TextInputStyle.Short).setRequired(false).setPlaceholder('e.g., 2m, 1m, 30s').setValue(chain.thresholds?.map(humanTime).join(', ') || '2m, 1m, 30s')
        )
      );
  },

  userWarn(userId) {
    const cfg = store.watchers[userId];
    return new ModalBuilder()
      .setCustomId(`modal:userwarn:${userId}:submit`)
      .setTitle('Early Warning Alerts')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('warn').setLabel('Alert before state ends').setStyle(TextInputStyle.Short).setRequired(false).setPlaceholder('e.g., 5m, 2m, 30s').setValue(cfg?.preTimesSec?.map(humanTime).join(', ') || '')
        )
      );
  },

  factionWarn(fid) {
    const f = store.factions.items[fid];
    return new ModalBuilder()
      .setCustomId(`modal:factionwarn:${fid}:submit`)
      .setTitle('Early Warning Alerts')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('warn').setLabel('Alert before state ends').setStyle(TextInputStyle.Short).setRequired(false).setPlaceholder('e.g., 5m, 2m, 30s').setValue(f?.preTimesSec?.map(humanTime).join(', ') || '')
        )
      );
  },

  factionOffline(fid) {
    const f = store.factions.items[fid];
    return new ModalBuilder()
      .setCustomId(`modal:factionoffline:${fid}:submit`)
      .setTitle('Offline Alert Settings')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('hours').setLabel('Hours before alert').setStyle(TextInputStyle.Short).setRequired(false).setPlaceholder('e.g., 24').setValue(String(f?.offline?.hours || 24))
        )
      );
  },

  delay(userId) {
    return new ModalBuilder()
      .setCustomId(`modal:delay:${userId}:submit`)
      .setTitle('Add Travel Delay')
      .addComponents(
        new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId('time').setLabel('Delay Time').setStyle(TextInputStyle.Short).setRequired(true).setPlaceholder('e.g., 5m, 30s, 1h')
        )
      );
  }
};

// ========= Pollers =========
class Poller {
  constructor(name) { 
    this.name = name; 
    this.items = []; 
    this.index = 0; 
    this.timer = null; 
    this.ticking = false; 
  }
  
  refresh(items) { 
    this.items = items; 
    if (this.index >= items.length) this.index = 0; 
  }
  
  start(ms, fn) { 
    this.stop(); 
    if (!this.items.length) return; 
    this.timer = setInterval(() => this.tick(fn), ms); 
    this.tick(fn); 
  }
  
  stop() { 
    clearInterval(this.timer); 
    this.timer = null; 
  }
  
  async tick(fn) {
    if (this.ticking || !this.items.length) return;
    this.ticking = true;
    
    // Get item and update index BEFORE calling fn (matches original)
    const item = this.items[this.index];
    this.index = (this.index + 1) % this.items.length;
    
    try { 
      await fn(item); 
    } catch (e) { 
      console.warn(`[${this.name}]`, e?.response?.status === 429 ? 'Rate limited' : e.message); 
    } finally { 
      this.ticking = false; 
    }
  }
}

const userPoller = new Poller('users');
const factionPoller = new Poller('factions');

// Session key for pre-alerts
const sessionKey = (state, status, travel) => {
  if (state === 'Traveling' && travel?.startedAt) return `T:${travel.direction}:${travel.startedAt}`;
  if (['Jail', 'Hospital'].includes(state) && status?.until) return `${state[0]}:${status.until}`;
  return null;
};

// Check and fire pre-alerts
const checkPreAlerts = async (id, name, state, status, travel, preTimesSec, preFired, onFire) => {
  if (!preTimesSec?.length) return;
  
  const endAt = state === 'Traveling' ? travel?.earliest : ['Jail', 'Hospital'].includes(state) ? Number(status?.until) : null;
  if (!endAt) return;
  
  const left = endAt - Math.floor(Date.now() / 1000);
  if (left <= 0) return;
  
  const key = sessionKey(state, status, travel);
  if (!key) return;
  
  preFired[key] ??= [];
  for (const t of preTimesSec) {
    if (left <= t && !preFired[key].includes(t)) {
      preFired[key].push(t);
      await onFire(name, id, state, endAt, left);
    }
  }
};

// User polling
const pollUser = async (userId) => {
  const cfg = store.watchers[userId];
  if (!cfg || cfg.enabled === false) return;

  let profile;
  try {
    profile = await api.getProfile(userId);
  } catch (e) {
    console.warn(`[poll] Failed to fetch ${userId}:`, e?.response?.status || e.message);
    return;
  }

  const status = profile?.status || {};
  const state = status.state || 'Okay';
  const prev = cfg.lastState;
  
  cfg.name = profile?.name || cfg.name;

  // First poll - just set baseline
  if (!prev) {
    cfg.lastState = state;
    cfg.travel = state === 'Traveling' ? createTravel(status) : null;
    store.save('baseline');
    console.log(`[baseline] ${cfg.name} (${userId}): ${state}`);
    return;
  }

  // Same state - just handle pre-alerts and travel updates
  if (state === prev) {
    // Pre-alerts for current state
    cfg.preFired ??= {};
    await checkPreAlerts(userId, cfg.name, state, status, cfg.travel, cfg.preTimesSec, cfg.preFired,
      (name, id, st, endAt, left) => notify(Embeds.preAlert(name, id, st, endAt, left)));
    
    // Travel direction/destination change while still traveling
    if (state === 'Traveling' && cfg.travel) {
      const newDir = parseTravelDir(status.description);
      const newDest = parseDestination(status.description);
      if (newDir !== cfg.travel.direction || newDest !== cfg.travel.dest) {
        cfg.travel = createTravel(status);
        store.save('travel-update');
        if (cfg.states?.includes('Traveling')) {
          await notify(Embeds.stateChange(userId, cfg.name, 'Traveling', 'Traveling', status, cfg.travel));
        }
      }
    }
    return;
  }

  // STATE CHANGED - Update state FIRST before anything else (critical fix!)
  const oldState = prev;
  cfg.lastState = state;
  cfg.travel = state === 'Traveling' ? createTravel(status) : null;
  
  // Clear pre-fired for new session
  cfg.preFired ??= {};
  const key = sessionKey(state, status, cfg.travel);
  if (key) delete cfg.preFired[key];
  
  // Save immediately so state is persisted even if alert fails
  store.save('state-change');
  
  console.log(`[state] ${cfg.name} (${userId}): ${oldState} â†’ ${state}`);
  
  // Now try to alert (failure won't affect state tracking)
  if (cfg.states?.includes(state)) {
    try {
      await notify(Embeds.stateChange(userId, cfg.name, oldState, state, status, cfg.travel), 
        Components.quickActions(userId, state));
    } catch (e) {
      console.error(`[alert] Failed to notify for ${cfg.name}:`, e.message);
    }
  }
};

// Faction polling
const pollFaction = async (fid) => {
  const fconf = store.factions.items[fid];
  if (!fconf || fconf.enabled === false) return;

  let data;
  try {
    data = await api.getFaction(fid);
  } catch (e) {
    console.warn(`[faction] Failed to fetch ${fid}:`, e?.response?.status || e.message);
    return;
  }

  const fName = data.name || `Faction ${fid}`;
  Object.assign(fconf, { name: data.name, tag: data.tag });

  // Respect milestone
  const curRespect = Number(data.respect || 0);
  const prevStep = fconf.lastRespectStep ?? Math.floor((fconf.lastRespect || 0) / 100000);
  const stepNow = Math.floor(curRespect / 100000);
  if (stepNow > prevStep) {
    try { await notify(Embeds.factionMilestone(fName, curRespect)); } catch {}
  }
  Object.assign(fconf, { lastRespect: curRespect, lastRespectStep: stepNow });

  const prevMap = fconf.members ??= {};
  const newMap = data.members || {};
  const watchStates = new Set(fconf.states || []);
  const offlineThresh = (fconf.offline?.hours || CONFIG.defaults.offlineHours) * 3600;
  const nowSec = Math.floor(Date.now() / 1000);

  // Joins
  for (const uid of Object.keys(newMap)) {
    if (!prevMap[uid]) {
      try { await notify(Embeds.factionJoinLeave('join', fName, uid, newMap[uid].name)); } catch {}
      prevMap[uid] = { name: newMap[uid].name, lastState: newMap[uid].status?.state || 'Okay', preFired: {} };
    }
  }
  
  // Leaves
  for (const uid of Object.keys(prevMap)) {
    if (!newMap[uid]) {
      try { await notify(Embeds.factionJoinLeave('leave', fName, uid, prevMap[uid].name || uid)); } catch {}
      delete prevMap[uid];
    }
  }

  // Member updates
  for (const [uid, m] of Object.entries(newMap)) {
    const cached = prevMap[uid];
    if (!cached) continue; // Just added above, skip
    
    const curState = m.status?.state || 'Okay';
    const tsLast = Number(m.last_action?.timestamp || 0);
    const prevState = cached.lastState;

    // Same state - handle travel updates and pre-alerts
    if (curState === prevState) {
      if (curState === 'Traveling' && cached.travel) {
        const newDir = parseTravelDir(m.status?.description);
        const newDest = parseDestination(m.status?.description);
        if (newDir !== cached.travel.direction || newDest !== cached.travel.dest) {
          cached.travel = createTravel(m.status);
        }
      }
      
      // Pre-alerts
      cached.preFired ??= {};
      await checkPreAlerts(uid, m.name, curState, m.status, cached.travel, fconf.preTimesSec, cached.preFired,
        (name, id, st, endAt, left) => notify(Embeds.preAlert(`${name} (${fName})`, id, st, endAt, left)));
    } else {
      // STATE CHANGED - Update FIRST
      const oldState = prevState;
      cached.lastState = curState;
      cached.travel = curState === 'Traveling' ? createTravel(m.status) : null;
      
      // Clear pre-fired
      cached.preFired ??= {};
      const key = sessionKey(curState, m.status, cached.travel);
      if (key) delete cached.preFired[key];
      
      console.log(`[faction] ${m.name} (${uid}): ${oldState} â†’ ${curState}`);
      
      // Alert after state is saved
      if (watchStates.has(curState)) {
        try {
          await notify(Embeds.factionMemberChange(fName, uid, m, oldState, curState, cached.travel));
        } catch (e) {
          console.error(`[faction-alert] Failed:`, e.message);
        }
      }
    }

    // Offline check
    if (fconf.offline?.enabled !== false && tsLast > 0) {
      const isOffline = (nowSec - tsLast) >= offlineThresh;
      if (isOffline && !cached.offlineNotified) {
        try { await notify(Embeds.factionOffline(fName, uid, m.name, tsLast, fconf.offline?.hours || CONFIG.defaults.offlineHours)); } catch {}
        cached.offlineNotified = true;
      } else if (!isOffline) {
        cached.offlineNotified = false;
      }
    }

    cached.name = m.name;
    cached.lastActionTs = tsLast || cached.lastActionTs;
  }

  store.save('faction-poll');
};

// Self pollers (bars, cooldowns, chain)
let barsTimer = null, cooldownTimer = null, chainTimer = null;

const pollBars = async () => {
  try {
    const data = await api.getBars();
    const { self } = store.data;

    for (const b of BARS) {
      if (!self.bars[b]) continue;
      const bar = data[b];
      const isFull = bar?.current >= bar?.maximum;
      if (isFull && !self.bars.wasFull[b]) {
        await notify(Embeds.barFull(b, bar));
      }
      self.bars.wasFull[b] = isFull;
      self.bars.last[b] = bar;
    }

    if (data.chain) self.chain.last = { ...data.chain, updatedAt: Date.now() };
    store.save('bars');
  } catch (e) { console.warn('[bars]', e.message); }
};

const pollChain = async () => {
  try {
    const data = await api.getBars();
    const chain = data.chain;
    if (!chain) return;

    const { self } = store.data;
    const prev = self.chain.last?.current ?? 0;
    const cur = chain.current ?? 0;

    if (cur < prev || (prev === 0 && cur > 0)) {
      self.chain.epochId = (self.chain.epochId || 0) + 1;
      self.chain.fired[self.chain.epochId] = [];
    }

    self.chain.last = { ...chain, updatedAt: Date.now() };

    if (!self.chain.enabled || cur < (self.chain.min || 10)) return;

    const fired = self.chain.fired[self.chain.epochId] ||= [];
    for (const t of (self.chain.thresholds || [120, 60, 30]).sort((a, b) => b - a)) {
      if (!fired.includes(t) && chain.timeout <= t && chain.timeout >= 0) {
        fired.push(t);
        await notify(Embeds.chainAlert(chain, t));
      }
    }
    store.save('chain');
  } catch (e) { console.warn('[chain]', e.message); }
};

const pollCooldowns = async () => {
  try {
    const cds = await api.getCooldowns();
    const { self } = store.data;
    let soonest = Infinity;

    for (const c of COOLDOWNS) {
      if (!self.cooldowns[c]) continue;
      const prev = self.cooldowns.last[c], val = cds[c] ?? 0;
      self.cooldowns.last[c] = val;
      if (prev > 0 && val <= 0) await notify(Embeds.cooldownReady(c));
      if (val > 0) soonest = Math.min(soonest, val);
    }

    store.save('cooldowns');
    scheduleCooldown(soonest < Infinity ? (soonest + 2) * 1000 : 30 * 60 * 1000);
  } catch (e) {
    console.warn('[cooldowns]', e.message);
    scheduleCooldown(5 * 60 * 1000);
  }
};

const scheduleCooldown = ms => {
  clearTimeout(cooldownTimer);
  if (COOLDOWNS.some(c => store.self.cooldowns[c])) {
    cooldownTimer = setTimeout(pollCooldowns, Math.max(2000, ms));
  }
};

const startPollers = () => {
  // Users
  const userIds = Object.keys(store.watchers).filter(id => store.watchers[id]?.enabled !== false);
  userPoller.refresh(userIds);
  userPoller.start(store.requestMs, pollUser);

  // Factions  
  const factionIds = Object.keys(store.factions.items).filter(id => store.factions.items[id]?.enabled !== false);
  factionPoller.refresh(factionIds);
  factionPoller.start(store.factions.requestMs, pollFaction);

  // Self
  clearInterval(barsTimer);
  clearInterval(chainTimer);
  if (BARS.some(b => store.self.bars[b]) || store.self.chain.enabled) {
    barsTimer = setInterval(pollBars, 60000);
    pollBars();
  }
  if (store.self.chain.enabled) {
    chainTimer = setInterval(pollChain, 10000);
  }
  if (COOLDOWNS.some(c => store.self.cooldowns[c])) pollCooldowns();
};

// Daily digest
let dailyTimer = null;
const scheduleDailyDigest = () => {
  const now = new Date();
  const next = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1, 0, 0, 5));
  clearTimeout(dailyTimer);
  dailyTimer = setTimeout(runDailyDigest, next - now);
};

const runDailyDigest = async () => {
  for (const [fid, f] of Object.entries(store.factions.items)) {
    if (f.enabled === false || f.daily?.enabled === false) continue;
    try {
      const data = await api.getFaction(fid);
      const cur = Number(data.respect || 0);
      f.daily ??= {};
      if (f.daily.respectAtMidnight != null) {
        await notify(Embeds.factionDaily(data.name || fid, cur - f.daily.respectAtMidnight, cur));
      }
      f.daily.respectAtMidnight = cur;
      store.save('daily');
      await sleep(900);
    } catch {}
  }
  scheduleDailyDigest();
};

// ========= Discord Client =========
client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.DirectMessages],
  partials: [Partials.Channel]
});

// Express
const app = express();
app.get('/', (_, res) => res.send('OK'));
app.get('/healthz', (_, res) => res.json({ ok: true }));
app.listen(CONFIG.port, () => console.log(`[web] :${CONFIG.port}`));

// Commands - simplified, UX-focused
const commands = [
  new SlashCommandBuilder().setName('dashboard').setDescription('ğŸ“Š Open the main control panel'),
  new SlashCommandBuilder().setName('help').setDescription('ğŸ“– Show help and commands'),
  new SlashCommandBuilder().setName('track')
    .setDescription('ğŸ‘ï¸ Start tracking a user or faction')
    .addSubcommand(sc => sc.setName('user').setDescription('Track a Torn user')
      .addIntegerOption(o => o.setName('id').setDescription('Torn user ID').setRequired(true))
      .addStringOption(o => o.setName('alerts').setDescription('States to alert (e.g., "jail, hospital" or "all")'))
      .addStringOption(o => o.setName('warn').setDescription('Early warnings (e.g., "5m, 2m")')))
    .addSubcommand(sc => sc.setName('faction').setDescription('Track a faction')
      .addIntegerOption(o => o.setName('id').setDescription('Faction ID').setRequired(true))
      .addStringOption(o => o.setName('alerts').setDescription('States to alert'))
      .addStringOption(o => o.setName('warn').setDescription('Early warnings'))
      .addIntegerOption(o => o.setName('offline').setDescription('Offline alert hours'))),
  new SlashCommandBuilder().setName('status').setDescription('ğŸ‘ï¸ Check current status')
    .addIntegerOption(o => o.setName('id').setDescription('User or faction ID').setRequired(true)),
  new SlashCommandBuilder().setName('remove').setDescription('ğŸ—‘ï¸ Stop tracking')
    .addIntegerOption(o => o.setName('id').setDescription('User or faction ID').setRequired(true)),
  new SlashCommandBuilder().setName('alerts').setDescription('ğŸ”” Configure personal alerts'),
  new SlashCommandBuilder().setName('delay').setDescription('â±ï¸ Add delay to travel ETA')
    .addIntegerOption(o => o.setName('id').setDescription('User ID').setRequired(true))
    .addStringOption(o => o.setName('time').setDescription('Delay time (e.g., "5m")').setRequired(true)),
].map(c => c.toJSON());

// Interaction handler
client.on('interactionCreate', async (i) => {
  if (i.user.id !== CONFIG.discord.ownerId) {
    return i.reply?.({ content: 'ğŸ”’ Owner only', ephemeral: true }).catch(() => {});
  }

  const eph = i.inGuild();

  try {
    // Modal submissions
    if (i.isModalSubmit()) {
      const [, type, id] = i.customId.split(':');
      await i.deferUpdate().catch(() => i.deferReply({ ephemeral: eph }));

      if (type === 'adduser') {
        const userId = i.fields.getTextInputValue('user_id').trim();
        const states = parseStates(i.fields.getTextInputValue('states') || 'all');
        const warn = parseTimes(i.fields.getTextInputValue('warn'));
        
        if (store.watchers[userId]) return i.editReply({ content: 'âš ï¸ Already tracking this user' });
        
        let profile;
        try { profile = await api.getProfile(userId); } catch { return i.editReply({ content: 'âŒ User not found' }); }
        
        store.watchers[userId] = {
          name: profile.name, states, preTimesSec: warn.length ? warn : undefined,
          enabled: true, lastState: profile.status?.state || 'Okay', preFired: {},
          travel: profile.status?.state === 'Traveling' ? createTravel(profile.status) : null
        };
        store.save('add-user');
        startPollers();
        
        return i.editReply({ content: `âœ… Now tracking **${profile.name}**`, embeds: [Embeds.userStatus(userId, profile, store.watchers[userId])], components: Components.userConfig(userId) });
      }

      if (type === 'addfaction') {
        const fid = i.fields.getTextInputValue('faction_id').trim();
        const states = parseStates(i.fields.getTextInputValue('states') || 'all');
        const offline = parseInt(i.fields.getTextInputValue('offline')) || CONFIG.defaults.offlineHours;
        
        if (store.factions.items[fid]) return i.editReply({ content: 'âš ï¸ Already tracking this faction' });
        
        let data;
        try { data = await api.getFaction(fid); } catch { return i.editReply({ content: 'âŒ Faction not found' }); }
        
        store.factions.items[fid] = {
          id: fid, name: data.name, tag: data.tag, enabled: true,
          states, members: {}, offline: { enabled: true, hours: offline }, daily: { enabled: true }
        };
        store.save('add-faction');
        startPollers();
        
        return i.editReply({ content: `âœ… Now tracking **${data.name}** (${Object.keys(data.members || {}).length} members)`, components: Components.factionConfig(fid) });
      }

      if (type === 'chain') {
        const min = parseInt(i.fields.getTextInputValue('min')) || 10;
        const thresholds = parseTimes(i.fields.getTextInputValue('thresholds'));
        store.self.chain.min = min;
        if (thresholds.length) store.self.chain.thresholds = thresholds;
        store.save('chain-config');
        return i.editReply({ embeds: [Embeds.alertsConfig()], components: Components.alertsButtons() });
      }

      if (type === 'userwarn' && id) {
        const warn = parseTimes(i.fields.getTextInputValue('warn'));
        const cfg = store.watchers[id];
        if (cfg) {
          cfg.preTimesSec = warn.length ? warn : undefined;
          store.save('user-warn');
        }
        const profile = await api.getProfile(id).catch(() => null);
        return i.editReply({ embeds: [Embeds.userStatus(id, profile, cfg)], components: Components.userConfig(id) });
      }

      if (type === 'factionwarn' && id) {
        const warn = parseTimes(i.fields.getTextInputValue('warn'));
        const f = store.factions.items[id];
        if (f) {
          f.preTimesSec = warn.length ? warn : undefined;
          store.save('faction-warn');
        }
        return i.editReply({ embeds: [Embeds.factionList()], components: Components.factionConfig(id) });
      }

      if (type === 'factionoffline' && id) {
        const hours = parseInt(i.fields.getTextInputValue('hours')) || CONFIG.defaults.offlineHours;
        const f = store.factions.items[id];
        if (f) {
          f.offline ??= {};
          f.offline.hours = hours;
          store.save('faction-offline');
        }
        return i.editReply({ components: Components.factionConfig(id) });
      }

      if (type === 'delay' && id) {
        const time = parseTime(i.fields.getTextInputValue('time')) || 0;
        const cfg = store.watchers[id];
        if (cfg?.travel) {
          cfg.travel.earliest = (cfg.travel.earliest || 0) + time;
          cfg.travel.latest = (cfg.travel.latest || 0) + time;
          store.save('delay');
        }
        const profile = await api.getProfile(id).catch(() => null);
        return i.editReply({ content: `âœ… Added ${humanTime(time)} delay`, embeds: [Embeds.userStatus(id, profile, cfg)] });
      }

      return;
    }

    // Buttons
    if (i.isButton()) {
      const [action, type, id] = i.customId.split(':');

      if (action === 'dash') {
        await i.deferUpdate();
        if (type === 'main' || type === 'refresh') return i.editReply({ embeds: [Embeds.dashboard()], components: Components.dashboardButtons() });
        if (type === 'users') return i.editReply({ embeds: [Embeds.userList()], components: Components.userListMenu() });
        if (type === 'factions') return i.editReply({ embeds: [Embeds.factionList()], components: Components.factionListMenu() });
        if (type === 'alerts') return i.editReply({ embeds: [Embeds.alertsConfig()], components: Components.alertsButtons() });
      }

      if (action === 'modal') {
        if (type === 'adduser') return i.showModal(Modals.addUser());
        if (type === 'addfaction') return i.showModal(Modals.addFaction());
        if (type === 'chain') return i.showModal(Modals.chainConfig());
        if (type === 'userwarn') return i.showModal(Modals.userWarn(id));
        if (type === 'factionwarn') return i.showModal(Modals.factionWarn(id));
        if (type === 'factionoffline') return i.showModal(Modals.factionOffline(id));
        if (type === 'delay') return i.showModal(Modals.delay(id));
      }

      if (action === 'toggle') {
        await i.deferUpdate();
        
        if (type === 'bar') {
          store.self.bars[id] = !store.self.bars[id];
          store.save('toggle-bar');
          startPollers();
          return i.editReply({ embeds: [Embeds.alertsConfig()], components: Components.alertsButtons() });
        }
        
        if (type === 'cd') {
          store.self.cooldowns[id] = !store.self.cooldowns[id];
          store.save('toggle-cd');
          startPollers();
          return i.editReply({ embeds: [Embeds.alertsConfig()], components: Components.alertsButtons() });
        }
        
        if (type === 'chain') {
          store.self.chain.enabled = !store.self.chain.enabled;
          store.save('toggle-chain');
          startPollers();
          return i.editReply({ embeds: [Embeds.alertsConfig()], components: Components.alertsButtons() });
        }
        
        if (type === 'user') {
          const cfg = store.watchers[id];
          if (cfg) cfg.enabled = cfg.enabled === false;
          store.save('toggle-user');
          startPollers();
          const profile = await api.getProfile(id).catch(() => null);
          return i.editReply({ embeds: [Embeds.userStatus(id, profile, cfg)], components: Components.userConfig(id) });
        }
        
        if (type === 'faction') {
          const f = store.factions.items[id];
          if (f) f.enabled = f.enabled === false;
          store.save('toggle-faction');
          startPollers();
          return i.editReply({ components: Components.factionConfig(id) });
        }
        
        if (type === 'foffline') {
          const f = store.factions.items[id];
          if (f) { f.offline ??= {}; f.offline.enabled = f.offline.enabled === false; }
          store.save('toggle-foffline');
          return i.editReply({ components: Components.factionConfig(id) });
        }
        
        if (type === 'fdaily') {
          const f = store.factions.items[id];
          if (f) { f.daily ??= {}; f.daily.enabled = f.daily.enabled === false; }
          store.save('toggle-fdaily');
          return i.editReply({ components: Components.factionConfig(id) });
        }
      }

      if (action === 'remove') {
        await i.deferUpdate();
        if (type === 'user') {
          delete store.watchers[id];
          store.save('remove-user');
          startPollers();
          return i.editReply({ content: 'âœ… User removed', embeds: [Embeds.userList()], components: Components.userListMenu() });
        }
        if (type === 'faction') {
          delete store.factions.items[id];
          store.save('remove-faction');
          startPollers();
          return i.editReply({ content: 'âœ… Faction removed', embeds: [Embeds.factionList()], components: Components.factionListMenu() });
        }
      }

      if (action === 'refresh') {
        await i.deferUpdate();
        if (type === 'user') {
          const cfg = store.watchers[id];
          const profile = await api.getProfile(id).catch(() => null);
          if (profile) {
            cfg.name = profile.name;
            cfg.lastState = profile.status?.state;
            if (profile.status?.state === 'Traveling') cfg.travel = createTravel(profile.status);
            store.save('refresh');
          }
          return i.editReply({ embeds: [Embeds.userStatus(id, profile, cfg)], components: Components.userConfig(id) });
        }
      }

      if (action === 'alerts' && type === 'refresh') {
        await i.deferUpdate();
        await pollBars().catch(() => {});
        await pollCooldowns().catch(() => {});
        return i.editReply({ embeds: [Embeds.alertsConfig()], components: Components.alertsButtons() });
      }

      return;
    }

    // Select menus
    if (i.isStringSelectMenu()) {
      await i.deferUpdate();
      const [type, id] = i.customId.split(':');

      if (type === 'select') {
        if (id === 'user') {
          const userId = i.values[0];
          const cfg = store.watchers[userId];
          const profile = await api.getProfile(userId).catch(() => null);
          return i.editReply({ embeds: [Embeds.userStatus(userId, profile, cfg)], components: Components.userConfig(userId) });
        }
        if (id === 'faction') {
          const fid = i.values[0];
          return i.editReply({ components: Components.factionConfig(fid) });
        }
      }

      if (type === 'states') {
        const cfg = store.watchers[id];
        if (cfg) cfg.states = i.values;
        store.save('states');
        const profile = await api.getProfile(id).catch(() => null);
        return i.editReply({ embeds: [Embeds.userStatus(id, profile, cfg)], components: Components.userConfig(id) });
      }

      if (type === 'fstates') {
        const f = store.factions.items[id];
        if (f) f.states = i.values;
        store.save('fstates');
        return i.editReply({ components: Components.factionConfig(id) });
      }

      return;
    }

    // Slash commands
    if (!i.isChatInputCommand()) return;
    await i.deferReply({ ephemeral: eph });

    if (i.commandName === 'dashboard') {
      return i.editReply({ embeds: [Embeds.dashboard()], components: Components.dashboardButtons() });
    }

    if (i.commandName === 'help') {
      return i.editReply({ embeds: [Embeds.help()] });
    }

    if (i.commandName === 'alerts') {
      return i.editReply({ embeds: [Embeds.alertsConfig()], components: Components.alertsButtons() });
    }

    if (i.commandName === 'track') {
      const sub = i.options.getSubcommand();
      
      if (sub === 'user') {
        const userId = String(i.options.getInteger('id'));
        const states = parseStates(i.options.getString('alerts'));
        const warn = parseTimes(i.options.getString('warn'));
        
        if (store.watchers[userId]) return i.editReply({ content: 'âš ï¸ Already tracking this user' });
        
        let profile;
        try { profile = await api.getProfile(userId); } catch { return i.editReply({ content: 'âŒ User not found' }); }
        
        store.watchers[userId] = {
          name: profile.name, states, preTimesSec: warn.length ? warn : undefined,
          enabled: true, lastState: profile.status?.state || 'Okay', preFired: {},
          travel: profile.status?.state === 'Traveling' ? createTravel(profile.status) : null
        };
        store.save('add');
        startPollers();
        
        return i.editReply({ embeds: [Embeds.userStatus(userId, profile, store.watchers[userId])], components: Components.userConfig(userId) });
      }
      
      if (sub === 'faction') {
        const fid = String(i.options.getInteger('id'));
        const states = parseStates(i.options.getString('alerts'));
        const warn = parseTimes(i.options.getString('warn'));
        const offline = i.options.getInteger('offline') || CONFIG.defaults.offlineHours;
        
        if (store.factions.items[fid]) return i.editReply({ content: 'âš ï¸ Already tracking this faction' });
        
        let data;
        try { data = await api.getFaction(fid); } catch { return i.editReply({ content: 'âŒ Faction not found' }); }
        
        store.factions.items[fid] = {
          id: fid, name: data.name, enabled: true, states,
          preTimesSec: warn.length ? warn : undefined,
          members: {}, offline: { enabled: true, hours: offline }, daily: { enabled: true }
        };
        store.save('add-faction');
        startPollers();
        
        return i.editReply({ content: `âœ… Tracking **${data.name}**`, components: Components.factionConfig(fid) });
      }
    }

    if (i.commandName === 'status') {
      const id = String(i.options.getInteger('id'));
      
      // Try user first
      try {
        const profile = await api.getProfile(id);
        const cfg = store.watchers[id];
        return i.editReply({ embeds: [Embeds.userStatus(id, profile, cfg)], components: cfg ? Components.userConfig(id) : Components.quickActions(id, profile.status?.state) });
      } catch {}
      
      // Try faction
      try {
        const data = await api.getFaction(id);
        const f = store.factions.items[id];
        const memberCount = Object.keys(data.members || {}).length;
        const emb = new EmbedBuilder()
          .setColor(COLORS.brand)
          .setTitle(`${EMOJI.faction} ${data.name}`)
          .addFields(
            { name: 'Members', value: String(memberCount), inline: true },
            { name: 'Respect', value: Number(data.respect || 0).toLocaleString(), inline: true },
            { name: 'Tracking', value: f ? (f.enabled === false ? `${EMOJI.off} Paused` : `${EMOJI.on} Active`) : 'Not tracked', inline: true }
          );
        return i.editReply({ embeds: [emb], components: f ? Components.factionConfig(id) : [] });
      } catch {}
      
      return i.editReply({ content: 'âŒ Not found' });
    }

    if (i.commandName === 'remove') {
      const id = String(i.options.getInteger('id'));
      
      if (store.watchers[id]) {
        delete store.watchers[id];
        store.save('remove');
        startPollers();
        return i.editReply({ content: 'âœ… User removed' });
      }
      
      if (store.factions.items[id]) {
        delete store.factions.items[id];
        store.save('remove');
        startPollers();
        return i.editReply({ content: 'âœ… Faction removed' });
      }
      
      return i.editReply({ content: 'âŒ Not found' });
    }

    if (i.commandName === 'delay') {
      const id = String(i.options.getInteger('id'));
      const time = parseTime(i.options.getString('time')) || 0;
      
      const cfg = store.watchers[id];
      if (!cfg?.travel) return i.editReply({ content: 'âŒ User not traveling' });
      
      cfg.travel.earliest = (cfg.travel.earliest || 0) + time;
      cfg.travel.latest = (cfg.travel.latest || 0) + time;
      store.save('delay');
      
      const profile = await api.getProfile(id).catch(() => null);
      return i.editReply({ content: `âœ… Added ${humanTime(time)} delay`, embeds: [Embeds.userStatus(id, profile, cfg)] });
    }

  } catch (e) {
    console.error('[interaction]', e);
    const msg = `âŒ ${e.message}`;
    (i.deferred || i.replied ? i.editReply(msg) : i.reply({ content: msg, ephemeral: true })).catch(() => {});
  }
});

// ========= Startup =========
store.load();

// Seed from env
if (!Object.keys(store.watchers).length && CONFIG.torn.userIds) {
  CONFIG.torn.userIds.split(',').filter(Boolean).forEach(id => {
    store.watchers[id.trim()] = { states: [...STATES], enabled: true, lastState: null, name: `User ${id}`, preFired: {} };
  });
  store.save('seed');
}

if (!Object.keys(store.factions.items).length && CONFIG.torn.factionIds) {
  CONFIG.torn.factionIds.split(',').filter(Boolean).forEach(id => {
    store.factions.items[id.trim()] = {
      id: id.trim(), enabled: true, states: [...STATES], members: {},
      offline: { enabled: true, hours: CONFIG.defaults.offlineHours }, daily: { enabled: true }
    };
  });
  store.save('faction-seed');
}

client.once('ready', async () => {
  console.log(`[discord] ${client.user.tag}`);
  
  try {
    if (CONFIG.discord.guildId) {
      const guild = await client.guilds.fetch(CONFIG.discord.guildId);
      await guild.commands.set(commands);
    }
    await client.application.commands.set(commands);
  } catch (e) { console.warn('[cmd]', e.message); }

  // Prime baselines
  for (const [id, cfg] of Object.entries(store.watchers)) {
    if (!cfg.lastState) {
      try {
        const p = await api.getProfile(id);
        cfg.name = p.name;
        cfg.lastState = p.status?.state || 'Okay';
        if (p.status?.state === 'Traveling') cfg.travel = createTravel(p.status);
        await sleep(500);
      } catch {}
    }
  }
  store.save('primed');

  startPollers();
  scheduleDailyDigest();
  
  console.log(`[ready] ${Object.keys(store.watchers).length} users, ${Object.keys(store.factions.items).length} factions`);
});

client.login(CONFIG.discord.token);

['SIGINT', 'SIGTERM'].forEach(s => process.on(s, () => { store.save('exit'); setTimeout(() => process.exit(0), 300); }));

================================================================================

File: package.json
----------------------------------------
{
    "name": "torn-tracker",
    "version": "2.0.0",
    "description": "Advanced Torn status tracker with Discord notifications",
    "main": "src/index.js",
    "scripts": {
      "start": "node src/index.js",
      "dev": "node --watch src/index.js"
    },
    "dependencies": {
      "axios": "^1.6.0",
      "discord.js": "^14.14.0",
      "dotenv": "^16.3.0",
      "express": "^4.18.0"
    },
    "engines": {
      "node": ">=18.0.0"
    }
  }

================================================================================
